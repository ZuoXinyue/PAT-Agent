[
  {
    "id": "peterson",
    "name": "Peterson's Algorithm",
    "matchtype": "loose match",
    "description": "This model implements the Peterson\u2019s mutual exclusion algorithm for certain amout of processes, which ensures that at most one process can be in the critical section at any time. The model explicitly tracks mutual exclusion and liveness properties.",
    "variable": "num_processes (at least 2)",
    "implementation": "#define N 2;\n\nvar step[N];\nvar pos[N];\nvar counter = 0; //which counts how many processes are in the critical session.\nProcess0() = Repeat0(1); cs.0{counter = counter+1;} -> reset{pos[0] = 0; counter = counter-1;} -> Process0();\nRepeat0(j) = [j < N] update.0.1{pos[0] = j;} -> update.0.2{step[j] = 0;} -> \n                ([step[j] != 0 || (pos[1] < j)]idle.j -> Repeat0(j+1))\n        [] [j == N] Skip;\n\nProcess1() = Repeat1(1); cs.1{counter = counter+1;} -> reset{pos[1] = 0; counter = counter-1;} -> Process1();\nRepeat1(j) = [j < N] update.1.1{pos[1] = j;} -> update.1.2{step[j] = 1;} -> \n                ([step[j] != 1 || (pos[0] < j)]idle.j -> Repeat1(j+1))\n        [] [j == N] Skip;\n\nPeterson() = Process0() ||| Process1();\n\n#define goal counter > 1;\n#assert Peterson() reaches goal;\n#assert Peterson() |= []<> cs.0;"
  },
  {
    "id": "dining_philosophers",
    "name": "Dining Philosophers",
    "matchtype": "loose match",
    "description": "This model encodes a classic synchronization problem - the Dining Philosopher Problem, with a certain number of philosophers. Each philosopher alternates between thinking and eating, but needs two forks (represented as shared resources) to eat. The challenge lies in preventing deadlock and ensuring fairness in fork acquisition and eating.",
    "variable": "num_philosophers (at least 2)",
    "implementation": "#define N 2;\n\nPhil(i) = get.i.(i+1)%N -> get.i.i -> eat.i -> put.i.(i+1)%N -> put.i.i -> Phil(i);\nFork(x) = get.x.x -> put.x.x -> Fork(x) [] get.(x-1)%N.x -> put.(x-1)%N.x -> Fork(x);\nCollege() = ||x:{0..N-1}@(Phil(x)||Fork(x));\nImplementation() = College() \\ {get.0.0,get.0.1,put.0.0,put.0.1,eat.1,get.1.1,get.1.0,put.1.1,put.1.0};\nSpecification() = eat.0 -> Specification();\n////////////////The Properties//////////////////\n#assert College() deadlockfree;\n#assert College() |= []<> eat.0;\n#assert Implementation() refines Specification();\n#assert Specification() refines Implementation();\n#assert Implementation() refines <F> Specification();\n#assert Specification() refines <F> Implementation();\n#assert Implementation() refines <FD> Specification();\n#assert Specification() refines <FD> Implementation();"
  },
  {
    "id": "milner_scheduler",
    "name": "Milner's Cyclic Scheduler",
    "matchtype": "loose match",
    "description": "This model implements the Milner's Cyclic Scheduler, originally described in Communication and Concurrency (1989), to coordinate a fixed number of cyclic processes. Each process follows a strict handoff discipline, forming a token ring-like structure where only one process performs work at a time, and the control (token) is passed cyclically.",
    "variable": "num_schedulers (at least 2)",
    "implementation": "#define N 10;\n#alphabet Cycle {ini.i,ini.(i+1)%N};\n\nCycle0         = a.0 -> ini.1 -> work.0 -> ini.0 -> Cycle0;\nCycle(i)       = ini.i -> a.i -> (work.i -> atomic{ini.(i+1)%N -> Skip}; Cycle(i) [] ini.(i+1)%N -> atomic{work.i -> Skip}; Cycle(i));\nMilnerAcyclic() = Cycle0 || (|| x:{1..N-1} @ Cycle(x)); \nImplementation()=(MilnerAcyclic() \\ {ini.0,a.0,work.1,ini.1,a.1,work.2,ini.2,a.2,work.3,ini.3,a.3,work.4,ini.4,a.4,work.5,ini.5,a.5,work.6,ini.6,a.6,work.7,ini.7,a.7,work.8,ini.8,a.8,work.9,ini.9,a.9});\nSpecification()=(work.0->Specification());\n\n////////////////The Properties//////////////////\n#assert MilnerAcyclic() deadlockfree;\n#assert MilnerAcyclic() |= []<>work.0;\n#assert Implementation() refines Specification();\n#assert Specification() refines Implementation();\n#assert Implementation() refines <F> Specification();\n#assert Specification() refines <F> Implementation();\n#assert Implementation() refines <FD> Specification();\n#assert Specification() refines <FD> Implementation();"
  },
  {
    "id": "readers_writers",
    "name": "Readers-Writers Problem",
    "matchtype": "loose match",
    "description": "This model formalizes the classic readers-writers synchronization problem, where multiple readers and writers interact with a shared resource under a centralized controller that ensures safe concurrent access. The model checks that only valid access sequences occur and identifies illegal interactions.",
    "variable": "num_persons (at least 2)",
    "implementation": "#define M 10;\n\nWriter() \t= startwrite -> stopwrite -> Writer();\nReader() \t= startread -> stopread -> Reader();\nReading(i) \t= [i == 0]Controller() []\n\t\t [i == M] stopread -> Reading(i-1) []\n\t\t [i > 0 && i < M] (startread -> Reading(i+1) [] stopread -> Reading(i-1));\n\nController() \t= startread -> Reading(1)\n\t\t [] stopread -> error -> Controller()\n\t\t [] startwrite -> (stopwrite -> Controller() [] stopread -> error -> Controller());\n\nReadersWriters() = Controller() || (|||x:{0..M-1} @ (Reader() ||| Writer()));\n\nImplementation() \t= ReadersWriters() \\ {startread, stopread, startwrite, stopwrite};\nSpecification() \t= error -> Specification();\n\n#alphabet Reading {startread,stopread};\n\n////////////////The Properties//////////////////\n#assert ReadersWriters() deadlockfree;\n#assert ReadersWriters() |= []<>error;\n#assert ReadersWriters() |= ![]<>error;\n#assert Implementation() refines Specification();\n#assert Specification() refines Implementation();\n#assert Implementation() refines <F> Specification();\n#assert Specification() refines <F> Implementation();\n#assert Implementation() refines <FD> Specification();\n#assert Specification() refines <FD> Implementation();"
  },
  {
    "id": "dijkstra",
    "name": "Dijkstra's Mutual Exclusion Algorithm",
    "matchtype": "loose match",
    "description": "This model implements the classical Dijkstra\u2019s Mutual Exclusion Algorithm for concurrent processes that coordinate access to a critical section using shared variables flag[] and turn. The goal is to ensure mutual exclusion, i.e., at most one process is in the critical section at any given time.",
    "variable": "num_processes (at least 2)",
    "implementation": "#define N 2;\n\nvar flag[N];\nvar enter_cs[N];\nvar turn;\n\nProcess(i) = set_flag.i {flag[i] = 1;} -> (Check1(i) ; (set_flag.i {flag[i] = 2;} -> Check2(i, 0)));\n\nCheck1(i) = if(turn != i)\n\t{\n\t\tif(flag[turn] == 0)\n\t\t{\n\t\t\tget_turn{turn = i;} -> Skip\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCheck1(i)\n\t\t}\n\t};\n\nCheck2(i, j) = \n\tif(j==N)\n\t{\n\t\tCS(i)\n\t}\n\telse if(j == i)\n\t{\n\t\tCheck2(i, j+1)\n\t}\n\telse if(flag[j] == 2)\n\t{\n\t\tProcess(i)\n\t}\n\telse \n\t{\n\t\tCheck2(i, j + 1)\n\t};\n\t\nCS(i) = cs.i{enter_cs[i] = 1;} -> exit.i {flag[i] = 0; enter_cs[i]= 0;} -> Process(i);\n\n\nDijkstra() = [] x:{0..N-1} @ (tau{turn = x} -> (|||y :{0..N-1}@Process(y)));\n\n//mutual exclution\n#define p ((enter_cs[0] + enter_cs[1]) >= 2);\n\n#assert Dijkstra() deadlockfree;\n#assert Dijkstra() reaches p;"
  },
  {
    "id": "needham",
    "name": "Needham-Schroeder Public-Key Protocol",
    "matchtype": "loose match",
    "description": "The Needham-Schroeder Public-Key Protocol (NSPK) is a classical cryptographic protocol designed to provide mutual authentication between two parties\u2014typically referred to as Alice (A, the initiator) and Bob (B, the responder)\u2014via asymmetric encryption. The original version is vulnerable to a well-known man-in-the-middle attack, while the fixed version includes an additional identity field to prevent this flaw.",
    "variable": "version (please enter either 'original' or 'fixed' in the box below)",
    "implementation": "//Original Version of Needham-Schroeder Public-Key Protocol\nenum {A, B, I, Na, Nb, gD};\n\n//ca: type 1 messages {x1,x2}PK{x3}\n//cb: type 2 messages {x1}PK{x2}\nchannel ca 0;\nchannel cb 0;\n\n//IniRunningAB is true iff initiator A takes part in a session of the protocol with B.\nvar IniRunningAB = false;\n//IniCommitAB is true iff initiator A commits to a session with B.\nvar IniCommitAB = false;\n//ResRunningAB is true iff responder B takes part in a session of the protocol with A.\nvar ResRunningAB = false;\n//ResCommitAB is true iff responder B commits to a session with A.\nvar ResCommitAB = false;\n\n//Initiator\nPIni(sender, receiver, nonce) =\n\tIniRunning_AB { if (sender == A && receiver == B) { IniRunningAB = true; } } ->\n\t//sending {nonce, sender}Pk{receiver}\n\tca!sender.nonce.sender.receiver ->\n\t\n\t//receiving {nonce, g1}Pk{sender}\n\tca?sender.nonce.g1.sender -> IniCommit_AB { if (sender == A && receiver == B) { IniCommitAB = true; } } ->\n\t\n\t//sending {g1}Pk{receiver}\n\tcb!sender.g1.receiver -> Skip;\n\n//Responder\nPRes(receiver, nonce) =\t\n\t//receiving {g2, g3}Pk{receiver}\n\tca?receiver.g2.g3.receiver ->\n\tResRunning_AB { if (g3 == A && receiver == B) { ResRunningAB = true; } } ->\n\t\n\t//sending {g2, nonce}Pk{g3}\n\tca!receiver.g2.nonce.g3 ->\n\t\n\t//receiving {nonce}Pk{receiver}\n\tcb?receiver.nonce.receiver ->\n\tResCommit_AB { if (g3 == A && receiver == B) { ResCommitAB = true; } } -> Skip;\n\n//Intruder knows Na\nvar kNa = false; \n//Intruder knows Nb\nvar kNb = false;\n//Intruder knows {Na, Nb}PK{A}\nvar k_Na_Nb__A = false;\n//Intruder knows {Na, A}PK{B}\nvar k_Na_A__B = false;\n//Intruder knows {Nb}PK{B}\nvar k_Nb__B = false;\n\n//Intruder Process, which always knows A, B, I, PK(A), PK(B), PK(I), SK(I) and Ng\nPI() =\n\tca!B.gD.A.B -> PI() []\n\tca!B.gD.B.B -> PI() []\n\tca!B.gD.I.B -> PI() []\n\t\n\tca!B.A.A.B -> PI []\n\tca!B.A.B.B -> PI []\n\tca!B.A.I.B -> PI []\n\t\n\tca!B.B.A.B -> PI() []\n\tca!B.B.B.B -> PI() []\n\tca!B.B.I.B -> PI() []\n\t\n\tca!B.I.A.B -> PI() []\n\tca!B.I.B.B -> PI() []\n\tca!B.I.I.B -> PI() []\n\t\n\t[kNa]                        ca!A.Na.Na.A -> PI() []\n\t[(kNa && kNb) || k_Na_Nb__A] ca!A.Na.Nb.A -> PI() []\n\t[kNa]                        ca!A.Na.gD.A -> PI() []\n\t\n\t[kNa] ca!A.Na.A.A -> PI() []\n\t[kNa] ca!A.Na.B.A -> PI() []\n\t[kNa] ca!A.Na.I.A -> PI() []\n\t\n\t[kNa || k_Na_A__B] ca!B.Na.A.B -> PI() []\n\t[kNa]              ca!B.Na.B.B -> PI() []\n\t[kNa]              ca!B.Na.I.B -> PI() []\n\t\n\t[kNb] ca!B.Nb.A.B -> PI() []\n\t[kNb] ca!B.Nb.B.B -> PI() []\n\t[kNb] ca!B.Nb.I.B -> PI() []\n\t\n\t[k_Nb__B || kNb] cb!B.Nb.B -> PI() []\n\t\n\tca?tmp1.x1.x2.x3\n\t-> InterceptChanA {\n\t\tif (x3 == I) {\n\t\t\tif (x1 == Na) { kNa = true; }\n\t\t\telse if (x1 == Nb) { kNb = true; }\n\t\t\tif (x2 == Na) { kNa = true; }\n\t\t\telse if (x2 == Nb) { kNb = true; }\n\t\t}\n\t\telse if (x1 == Na && x2 == A && x3 == B) { k_Na_A__B = true; }\n\t\telse if (x1 == Na && x2 == Nb && x3 == A) { k_Na_Nb__A = true; }\n\t}\n\t-> PI() []\n\t\n\tcb?tmp2.y1.y2\n\t-> InterceptChanB {\n\t\tif (y2 == I) {\n\t\t\tif (y1 == Na) { kNa = true; }\n\t\t\telse if (y1 == Nb) { kNb = true; }\n\t\t}\n\t\telse if (y1 == Nb && y2 == B) { k_Nb__B = true; }\n\t}\n\t-> PI();\n\nProtocol = ( PIni(A, I, Na) [] PIni(A, B, Na) ) ||| PRes(B, Nb) ||| PI;\n\n#define iniRunningAB (IniRunningAB == true);\n#define iniCommitAB (IniCommitAB == true);\n#define resRunningAB (ResRunningAB == true);\n#define resCommitAB (ResCommitAB == true);\n\n//Authentication of B to A can thus be expressed saying that ResRunningAB must become true before IniCommitAB.\n//i.e., the initiator A commits to a session with B only if B has indeed taken part in a run of the protocol with A.\n#assert Protocol |= [] ( ([] !iniCommitAB) || (!iniCommitAB U resRunningAB) );\n\n//The converse authentication property corresponds to saying that IniRunningAB becomes true before ResCommitAB.\n//The flaw of the protocol is shown by this model\n#assert Protocol |= [] ( ([] !resCommitAB) || (!resCommitAB U iniRunningAB) );\n\n#assert Protocol deadlockfree;"
  },
  {
    "id": "interrupt_controller",
    "name": "Interrupt Controller",
    "matchtype": "loose match",
    "description": "This Interrupt Controller with Priorities model formalizes a scenario inspired by the example in 'Priorities in Process Algebras' (Cleveland & Hennessy, 1990), demonstrating how priorities influence system behavior in the presence of asynchronous events and interrupts.",
    "variable": "counter_modulo (at least 2)",
    "implementation": "#define MODULO 16;\n\n// Input to the counter\nchannel up 0;\nchannel down 0;\n\n// Shut down request\nchannel shutdown 0;\n\n// Internal communication\nchannel i 0;\n\nvar noOfError = 0;\n\nvar count;\n\nInt = shutdown?0 -> i!0 -> Stop;\n\nC = up?0 {count = (count + 1) % MODULO;} -> C [] down?0 {if(count > 0) {count = count - 1;}} -> C [] i?0 -> Stop;\n\nEvn = up!0 -> Evn [] down!0 -> Evn []  shutdown!0 -> ( up!0 -> Error() [] down!0 -> Error());\n\nError = error{noOfError++} -> Stop;\n\naSys = Int ||| C ||| Evn;\n\n#define goal noOfError > 0;\n#assert aSys reaches goal;"
  },
  {
    "id": "abp",
    "name": "Alternating Bit Protocol (ABP)",
    "matchtype": "loose match",
    "description": "This Alternating Bit Protocol (ABP) model implements a classic reliable data transmission protocol over an unreliable communication channel. It ensures that each bit of data sent by the sender is correctly received and acknowledged by the receiver, despite the possibility of message loss. The model captures key components of ABP using asynchronous processes and synchronization mechanisms.",
    "variable": "channel_size (at least 1)",
    "implementation": "#define CHANNELSIZE 1;\n\nchannel c CHANNELSIZE; //unreliable channel.\nchannel d CHANNELSIZE; //perfect channel.\nchannel tmr 0; //a synchronous channel between sender and timer, which is used to implement premature timeout.\n\nSender(alterbit) = (c!alterbit -> Skip [] lost -> Skip);\n                                  tmr!1 -> Wait4Response(alterbit);\n\nWait4Response(alterbit) = (d?x -> ifa (x==alterbit) {\n                                      tmr!0 -> Sender(1-alterbit)\n                                  } else {\n                                      Wait4Response(alterbit)\n                                  })\n                          [] tmr?2 -> Sender(alterbit);\n\nReceiver(alterbit) = c?x -> ifa (x==alterbit) {\n                                 d!alterbit -> Receiver(1-alterbit)\n                            } else {\n                                 Receiver(alterbit)\n                            };\n\nTimer = tmr?1 -> (tmr?0 -> Timer [] tmr!2 -> Timer);\n\nABP = Sender(0) ||| Receiver(0) ||| Timer;\n\n#assert ABP deadlockfree;\n#assert ABP |= []<> lost;"
  },
  {
    "id": "tpcp",
    "name": "Two Phase Commit Protocol (TPCP)",
    "matchtype": "loose match",
    "description": "This Two-Phase Commit Protocol (TPCP) model simulates a standard atomic commit protocol used in distributed systems to ensure all-or-nothing agreement among multiple participants (pages) during a transaction. The model captures coordination between a central coordinator and multiple pages using message-passing and control flow mechanisms, and verifies key correctness and liveness properties.",
    "variable": "num_pages (at least 2)",
    "implementation": "#define N 2; //number of pages\nenum {Yes, No, Commit, Abort}; //constants\n//channel result 0;\n//channel inform 0;\nchannel vote 0;\nvar hasNo = false;\n \n//The following models the coordinator \nCoord(decC) = (|||{N}@ request -> Skip); \n\t\t\t  (|||{N}@ vote?vo -> atomic{tau{if (vo == No) {hasNo = true;}} -> Skip}); \n\t\t\t  decide -> \n\t\t\t  (([hasNo == false] (|||{N}@inform.Commit -> Skip); CoordPhaseTwo(Commit)) [] ([hasNo == true] (|||{N}@inform.Abort -> Skip); CoordPhaseTwo(Abort)));\nCoordPhaseTwo(decC) = |||{N}@acknowledge -> Skip;\n\n//The following models a page\nPage(decP, stable) = request -> execute -> (vote!Yes -> PhaseTwo(decP) [] vote!No -> PhaseTwo(decP));\nPhaseTwo(decP) = inform.Commit -> complete -> result.decP -> acknowledge -> Skip\n\t\t\t\t\t [] inform.Abort -> undo -> result.decP -> acknowledge -> Skip;\n\n#alphabet Coord {request, inform.Commit, inform.Abort, acknowledge};\n#alphabet Page {request, inform.Commit, inform.Abort, acknowledge};\n\t\t\t\t\t\t\nSystem = Coord(Abort) || (|||{N}@Page(Abort, true));\nImplementation = System \\{request, execute, acknowledge, inform.Abort, inform.Commit, decide, result.Abort, result.Commit};\n\n#assert System deadlockfree;\n#define has hasNo == 1;\n#assert System |= [](has -> <> undo);\n#assert System |= [](request -> <> undo);\n\nSpecification = PC(N);\nPC(i) = [i == 0](|||{N}@complete -> Skip)\n\t\t\t[]\n\t\t\t[i > 0]\t(vote.Yes -> PC(i-1) [] vote.No -> PU(i-1));\nPU(i) = [i == 0](|||{N}@undo -> Skip)\n\t\t\t[]\n\t\t\t[i > 0](vote.Yes -> PU(i-1) [] vote.No -> PU(i-1));\n#assert Specification deadlockfree;\n\n#assert Implementation refines Specification;"
  },
  {
    "id": "minesweeper",
    "name": "Minesweeper Game",
    "matchtype": "loose match",
    "description": "This model implements the Minesweeper Puzzle, showcasing how the logic of the classic grid-based game is encoded and verified in a formal setting. The player is initially presented with a grid of undistinguished squares. Some randomly selected squares, unknown to the player, are designated to contain mines. The game is won when all mine-free squares are revealed.",
    "variable": "",
    "implementation": "//@@Minesweeper Game@@\n//The following are constants of the Minesweeper game\n#define Ro 4; // Number of Rows\n#define Co 4; // Number of Columns\n\n#define b -1; // Indicates a Mine\n#define s 0; // Indicates a blank Space\n\n#define close 9; // Square is closed\n#define open 8; // Square is open\n#define flag -9; // Square is flagged\n\nvar NumOfClick = 0; // The number of useful left-clicks.\nvar recursiveOrnot = false;\n//Click[Row][Column] records the state of the square.\n//   col number     :0 1 2 3 \nvar click[Ro][Co] = [close,close,close,close, //Row 0\n\t\t\t\t     close,close,close,close, //Row 1\n\t\t\t\t     close,close,close,close, //Row 2\n\t\t\t\t     close,close,close,close];//Row 3\n\n//board[Row][Column] indicates the cell is either a mine, a number or a blank square\n//   col number    :0 1 2 3 \nvar board[Ro][Co] = [1,b,2,1,\n                     1,1,2,b,\n                     1,1,1,1,\n                     b,1,s,s];\n\t\t\t\t\t \n//Game Initialization\nGame() = ([!goal_win && !goal_lose]([]x:{0..(Ro - 1)}@[]y:{0..(Co - 1)}@ Choice(x,y)))[]([goal_win || goal_lose]Skip);\nChoice(x,y)= [click[x][y]==close||click[x][y]==flag](([click[x][y]==close](IncreaseTurn(x,y)))[](RightClick(x,y);Game()));\nIncreaseTurn(x,y) = increase{NumOfClick++}->LeftClick(x,y); //Note: We only count the number of useful left-click (See Section 3.1.4).\n\n//If the square contains a mine or a number, leftclick just open this square. If the square is a blank square, leftclick will open this square and its neighbour squares recursively\nLeftClick(x,y) = if(board[x][y]==s && click[x][y]!=open && click[x][y]!=flag)\n{\n\tif(x == 0 && y == 0)\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x + 1,y) ;\n\t\t\tLeftClick(x + 1,y + 1) ; LeftClick(x,y + 1);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(x == 0 && y == (Co - 1)) \n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x,y - 1) ; LeftClick(x + 1,y - 1) ; LeftClick(x + 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(x == (Ro - 1) && y == 0)\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x,y + 1) ; LeftClick(x - 1,y + 1) ; LeftClick(x - 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(x == (Ro - 1) && y == (Co - 1))\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x - 1,y - 1) ; LeftClick(x,y - 1) ;\n\t\t\tLeftClick(x - 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(x == 0)\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x,y - 1) ; LeftClick(x + 1,y - 1) ; LeftClick(x + 1,y) ;\n\t\t\tLeftClick(x + 1,y + 1) ; LeftClick(x,y + 1);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(y == 0)\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x + 1,y) ;\n\t\t\tLeftClick(x + 1,y + 1) ; LeftClick(x,y + 1) ; LeftClick(x - 1,y + 1) ; LeftClick(x - 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(x == (Ro - 1))\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x - 1,y - 1) ; LeftClick(x,y - 1) ;\n\t\t\tLeftClick(x,y + 1) ; LeftClick(x - 1,y + 1) ; LeftClick(x - 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse if(y == (Co - 1))\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x - 1,y - 1) ; LeftClick(x,y - 1) ; LeftClick(x + 1,y - 1) ; LeftClick(x + 1,y) ;\n\t\t\tLeftClick(x - 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n\telse\n\t{\n\t\tbubble{click[x][y]=open;recursiveOrnot = true}\n\t\t->LeftClick(x - 1,y - 1) ; LeftClick(x,y - 1) ; LeftClick(x + 1,y - 1) ; LeftClick(x + 1,y) ;\n\t\t\tLeftClick(x + 1,y + 1) ; LeftClick(x,y + 1) ; LeftClick(x - 1,y + 1) ; LeftClick(x - 1,y);changeVar{recursiveOrnot = false}->Game()\n\t}\n}\nelse if (click[x][y]!=open && click[x][y]!=flag)\n{\n\tif (recursiveOrnot == false){penacell{click[x][y]=open}->Game()}\n\telse {penacell{click[x][y]=open}->Skip}\n}\nelse{\n\tSkip\n};\n\n//RightClick is used to either flag a square or unflag a square which has been flaged before \nRightClick(x,y) = [click[x][y]!=open && ( (x==0&&y==1) || (x==1&&y==3) || (x==3&&y==0)) ]flagacell{click[x][y]=click[x][y]*(-1)}->Skip;\n\n//(Winning)Game ends when all the squares that do not contain the mine are opened, \n//and squares with mine are either closed or flagged.\n#define goal_win (click[0][0] == open && (click[0][1] == close || click[0][1] == flag) && click[0][2] == open && click[0][3] == open && click[1][0] == open && click[1][1] == open && click[1][2] == open && (click[1][3] == close||click[1][3] == flag) && click[2][0] == open && click[2][1] == open && click[2][2] == open && click[2][3] == open && (click[3][0] == close||click[3][0] == flag)&& click[3][1] == open && click[3][2] == open && click[3][3] == open);\n\n//(Losing)Game ends when any of the squares containing mines is opened.\n#define goal_lose (click[0][1]==open || click[1][3]==open || click[3][0]==open);\n\n#assert Game() reaches goal_win;\n#assert Game() reaches goal_win with min(NumOfClick); //Least number of steps required.\n#assert Game() reaches goal_lose;\n#assert Game() reaches goal_lose with min(NumOfClick); //Least number of steps required.\n\n//Checking properties of Minesweeper.\n#assert Game() deadlockfree;\n#assert Game() deterministic;\n"
  },
  {
    "id": "rubik_cube",
    "name": "The Rubik\u2019s Cube Game",
    "matchtype": "loose match",
    "description": "This system models the Rubik\u2019s Cube Puzzle, a highly popular three-dimensional combination puzzle invented in the 1970s. The cube consists of six faces, each subdivided into a 3\u00d73 grid of colored stickers. The objective is to manipulate the cube by rotating its layers until each of the six faces is restored to a single, uniform color. In this model, moves are defined that allow rotating rows, columns, and face slices, simulating the real cube\u2019s mechanical behavior.",
    "variable": "",
    "implementation": "#define white 1;\n#define yellow 2;\n#define red 3;\n#define blue 4;\n#define green 5;\n#define orange 6;\n\n//this model models the initial configuration \nvar Cubix = [\t\t\tblue, \tyellow, blue, \n\t\t\t\t\t\tgreen, \tgreen, \tgreen,\n\t\t\t\t\t\tred, \tyellow, yellow,\nred, \tblue, \tgreen,\twhite,\tred,\torange,\tblue,\torange,\torange,\nblue, \tblue, \tblue,\torange,\torange,\twhite,\torange,\twhite,\tred,\norange, blue, \twhite,\torange,\twhite,\tred,\tyellow,\tred,\torange,\n\t\t\t\t\t\tgreen, \tgreen, \twhite, \n\t\t\t\t\t\tyellow, yellow, white,\n\t\t\t\t\t\twhite, \tyellow, blue,\n\t\t\t\t\t\tyellow, white, \tred, \n\t\t\t\t\t\tred, \tred, \tgreen,\n\t\t\t\t\t\tgreen, \torange, green];\nvar CubixPrime = [\t\tblue, \tyellow, blue, \n\t\t\t\t\t\tgreen, \tgreen, \tgreen,\n\t\t\t\t\t\tred, \tyellow, yellow,\nred, \tblue, \tgreen,\twhite,\tred,\torange,\tblue,\torange,\torange,\nblue, \tblue, \tblue,\torange,\torange,\twhite,\torange,\twhite,\tred,\norange, blue, \twhite,\torange,\twhite,\tred,\tyellow,\tred,\torange,\n\t\t\t\t\t\tgreen, \tgreen, \twhite, \n\t\t\t\t\t\tyellow, yellow, white,\n\t\t\t\t\t\twhite, \tyellow, blue,\n\t\t\t\t\t\tyellow, white, \tred, \n\t\t\t\t\t\tred, \tred, \tgreen,\n\t\t\t\t\t\tgreen, \torange, green];\n\nLeftTop() = turn_top_row_left{\n\t\t\t\t//the top face\n\t\t\t\tCubixPrime[0] = Cubix[6]; CubixPrime[1] = Cubix[3];\tCubixPrime[2] = Cubix[0];\n\t\t\t\tCubixPrime[3] = Cubix[7]; CubixPrime[5] = Cubix[1]; CubixPrime[6] = Cubix[8];\n\t\t\t\tCubixPrime[7] = Cubix[5]; CubixPrime[8] = Cubix[2];\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[9] = Cubix[12]; CubixPrime[10] = Cubix[13];\n\t\t\t\tCubixPrime[11] = Cubix[14]; CubixPrime[12] = Cubix[15];\n\t\t\t\tCubixPrime[13] = Cubix[16]; CubixPrime[14] = Cubix[17];\n\t\t\t\tCubixPrime[15] = Cubix[53]; CubixPrime[16] = Cubix[52];\n\t\t\t\tCubixPrime[17] = Cubix[51]; CubixPrime[51] = Cubix[11];\n\t\t\t\tCubixPrime[52] = Cubix[10]; CubixPrime[53] = Cubix[9];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\nLeftMiddle() = turn_middle_row_left{\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[18] = Cubix[21]; CubixPrime[19] = Cubix[22];\n\t\t\t\tCubixPrime[20] = Cubix[23]; CubixPrime[21] = Cubix[24];\n\t\t\t\tCubixPrime[22] = Cubix[25]; CubixPrime[23] = Cubix[26];\n\t\t\t\tCubixPrime[24] = Cubix[50]; CubixPrime[25] = Cubix[49];\n\t\t\t\tCubixPrime[26] = Cubix[48]; CubixPrime[48] = Cubix[20];\n\t\t\t\tCubixPrime[49] = Cubix[19]; CubixPrime[50] = Cubix[18];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nLeftBottom() = turn_bottom_row_left{\n\t\t\t\t//the bottom face\n\t\t\t\tCubixPrime[36] = Cubix[38]; CubixPrime[37] = Cubix[41];\tCubixPrime[38] = Cubix[44];\n\t\t\t\tCubixPrime[39] = Cubix[37]; CubixPrime[41] = Cubix[43]; CubixPrime[42] = Cubix[36];\n\t\t\t\tCubixPrime[43] = Cubix[39]; CubixPrime[44] = Cubix[42];\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[27] = Cubix[30]; CubixPrime[28] = Cubix[31];\n\t\t\t\tCubixPrime[29] = Cubix[32]; CubixPrime[30] = Cubix[33];\n\t\t\t\tCubixPrime[31] = Cubix[34]; CubixPrime[32] = Cubix[35];\n\t\t\t\tCubixPrime[33] = Cubix[47]; CubixPrime[34] = Cubix[46];\n\t\t\t\tCubixPrime[35] = Cubix[45]; CubixPrime[45] = Cubix[29];\n\t\t\t\tCubixPrime[46] = Cubix[28]; CubixPrime[47] = Cubix[27];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nLeftUp() = turn_left_column_up{\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[9] = Cubix[11]; CubixPrime[10] = Cubix[20];\tCubixPrime[11] = Cubix[29];\n\t\t\t\tCubixPrime[18] = Cubix[10]; CubixPrime[20] = Cubix[28]; CubixPrime[27] = Cubix[9];\n\t\t\t\tCubixPrime[28] = Cubix[18]; CubixPrime[29] = Cubix[27];\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[0] = Cubix[12]; CubixPrime[3] = Cubix[21];\n\t\t\t\tCubixPrime[6] = Cubix[30]; CubixPrime[12] = Cubix[36];\n\t\t\t\tCubixPrime[21] = Cubix[39]; CubixPrime[30] = Cubix[42];\n\t\t\t\tCubixPrime[36] = Cubix[45]; CubixPrime[39] = Cubix[48];\n\t\t\t\tCubixPrime[42] = Cubix[51]; CubixPrime[45] = Cubix[0];\n\t\t\t\tCubixPrime[48] = Cubix[3]; CubixPrime[51] = Cubix[6];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nMiddleUp() = turn_middle_column_up{\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[1] = Cubix[13]; CubixPrime[4] = Cubix[22];\n\t\t\t\tCubixPrime[7] = Cubix[31]; CubixPrime[13] = Cubix[37];\n\t\t\t\tCubixPrime[22] = Cubix[40]; CubixPrime[31] = Cubix[43];\n\t\t\t\tCubixPrime[37] = Cubix[46]; CubixPrime[40] = Cubix[49];\n\t\t\t\tCubixPrime[43] = Cubix[52]; CubixPrime[46] = Cubix[1];\n\t\t\t\tCubixPrime[49] = Cubix[4]; CubixPrime[52] = Cubix[7];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nRightUp() = turn_right_column_up{\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[15] = Cubix[33]; CubixPrime[16] = Cubix[24];\tCubixPrime[17] = Cubix[15];\n\t\t\t\tCubixPrime[24] = Cubix[34]; CubixPrime[26] = Cubix[16]; CubixPrime[33] = Cubix[35];\n\t\t\t\tCubixPrime[34] = Cubix[26]; CubixPrime[35] = Cubix[17];\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[2] = Cubix[14]; CubixPrime[5] = Cubix[23];\n\t\t\t\tCubixPrime[8] = Cubix[32]; CubixPrime[14] = Cubix[38];\n\t\t\t\tCubixPrime[23] = Cubix[41]; CubixPrime[32] = Cubix[44];\n\t\t\t\tCubixPrime[38] = Cubix[47]; CubixPrime[41] = Cubix[50];\n\t\t\t\tCubixPrime[44] = Cubix[53]; CubixPrime[47] = Cubix[2];\n\t\t\t\tCubixPrime[50] = Cubix[5]; CubixPrime[53] = Cubix[8];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nLeftBack() = turn_back_left{\n\t\t\t\t//the bottom face\n\t\t\t\tCubixPrime[51] = Cubix[53]; CubixPrime[52] = Cubix[50];\tCubixPrime[53] = Cubix[47];\n\t\t\t\tCubixPrime[48] = Cubix[52]; CubixPrime[50] = Cubix[46]; CubixPrime[45] = Cubix[51];\n\t\t\t\tCubixPrime[46] = Cubix[48]; CubixPrime[47] = Cubix[45];\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[0] = Cubix[17]; CubixPrime[1] = Cubix[26];\n\t\t\t\tCubixPrime[2] = Cubix[35]; CubixPrime[17] = Cubix[44];\n\t\t\t\tCubixPrime[26] = Cubix[43]; CubixPrime[35] = Cubix[42];\n\t\t\t\tCubixPrime[44] = Cubix[27]; CubixPrime[43] = Cubix[18];\n\t\t\t\tCubixPrime[42] = Cubix[9]; CubixPrime[27] = Cubix[0];\n\t\t\t\tCubixPrime[18] = Cubix[1]; CubixPrime[9] = Cubix[2];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nLeftMiddleBack() = turn_middle_back_left{\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[3] = Cubix[16]; CubixPrime[4] = Cubix[25];\n\t\t\t\tCubixPrime[5] = Cubix[34]; CubixPrime[16] = Cubix[41];\n\t\t\t\tCubixPrime[25] = Cubix[40]; CubixPrime[34] = Cubix[39];\n\t\t\t\tCubixPrime[41] = Cubix[28]; CubixPrime[40] = Cubix[19];\n\t\t\t\tCubixPrime[39] = Cubix[10]; CubixPrime[28] = Cubix[3];\n\t\t\t\tCubixPrime[19] = Cubix[4]; CubixPrime[10] = Cubix[5];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nLeftFrontBack() = turn_front_back_left{\n\t\t\t\t//the front face\n\t\t\t\tCubixPrime[12] = Cubix[14]; CubixPrime[13] = Cubix[23];\tCubixPrime[14] = Cubix[32];\n\t\t\t\tCubixPrime[21] = Cubix[13]; CubixPrime[23] = Cubix[31]; CubixPrime[30] = Cubix[12];\n\t\t\t\tCubixPrime[31] = Cubix[21]; CubixPrime[32] = Cubix[30];\n\t\t\t\t//the side face\n\t\t\t\tCubixPrime[6] = Cubix[15]; CubixPrime[7] = Cubix[24];\n\t\t\t\tCubixPrime[8] = Cubix[33]; CubixPrime[15] = Cubix[38];\n\t\t\t\tCubixPrime[24] = Cubix[37]; CubixPrime[33] = Cubix[36];\n\t\t\t\tCubixPrime[38] = Cubix[29]; CubixPrime[37] = Cubix[20];\n\t\t\t\tCubixPrime[36] = Cubix[11]; CubixPrime[29] = Cubix[6];\n\t\t\t\tCubixPrime[20] = Cubix[7]; CubixPrime[11] = Cubix[8];\n\t\t\t\tCubix = CubixPrime;\n\t\t\t} -> Game();\n\nGame() = LeftTop() [] \n\t\tLeftMiddle() []\n\t\tLeftBottom() []\n\t\tLeftUp() []\n\t\tMiddleUp() []\n\t\tRightUp() []\n\t\tLeftBack() []\n\t\tLeftMiddleBack() []\n\t\tLeftFrontBack(); \n\t\t\n#define goal Cubix[0] == Cubix[1] && Cubix[1] == Cubix[2] && Cubix[2] == Cubix[3] && \n\t\t\t Cubix[3] == Cubix[4] && Cubix[4] == Cubix[5] && Cubix[5] == Cubix[6] &&   \n\t\t\t Cubix[6] == Cubix[7] && Cubix[7] == Cubix[8] &&   \n\t\t\t Cubix[9] == Cubix[10] && Cubix[10] == Cubix[11] && Cubix[11] == Cubix[18] && \n\t\t\t Cubix[18] == Cubix[19] && Cubix[19] == Cubix[20] && Cubix[20] == Cubix[27] &&   \n\t\t\t Cubix[27] == Cubix[28] && Cubix[28] == Cubix[29] &&\t\t\t \n\t\t\t Cubix[12] == Cubix[13] && Cubix[13] == Cubix[14] && Cubix[14] == Cubix[21] && \n\t\t\t Cubix[21] == Cubix[22] && Cubix[22] == Cubix[23] && Cubix[23] == Cubix[30] &&   \n\t\t\t Cubix[30] == Cubix[31] && Cubix[31] == Cubix[32] &&\t\t\t \n\t\t\t Cubix[15] == Cubix[16] && Cubix[16] == Cubix[17] && Cubix[17] == Cubix[24] && \n\t\t\t Cubix[24] == Cubix[25] && Cubix[25] == Cubix[26] && Cubix[26] == Cubix[33] &&   \n\t\t\t Cubix[33] == Cubix[34] && Cubix[34] == Cubix[35] &&\t\t\t \n\t\t\t Cubix[36] == Cubix[37] && Cubix[37] == Cubix[38] && Cubix[38] == Cubix[39] && \n\t\t\t Cubix[39] == Cubix[40] && Cubix[40] == Cubix[41] && Cubix[41] == Cubix[42] &&   \n\t\t\t Cubix[42] == Cubix[43] && Cubix[43] == Cubix[44] &&\t\t\t \n\t\t\t Cubix[45] == Cubix[46] && Cubix[46] == Cubix[47] && Cubix[47] == Cubix[48] && \n\t\t\t Cubix[48] == Cubix[49] && Cubix[49] == Cubix[50] && Cubix[50] == Cubix[51] &&   \n\t\t\t Cubix[51] == Cubix[52] && Cubix[52] == Cubix[53];\n#assert Game() reaches goal;\n\n//this model models the cubix \n/**************************************\n\t\t\t0\t1 \t2 \t \n\t\t\t3\t4 \t5 \t\n\t\t\t6\t7 \t8 \t\n9\t10 \t11 \t12\t13\t14\t15\t16\t17\t\n18\t19 \t20 \t21\t22\t23\t24\t25\t26\t\n27\t28 \t29 \t30\t31\t32\t33\t34\t35\t\n\t\t\t36\t37 \t38  \n\t\t\t39\t40 \t41\n\t\t\t42\t43 \t44\n\t\t\t45\t46 \t47 \t\t\t\t\t51\t52\t53\n\t\t\t48\t49 \t50\t\t\t\t\t48\t49\t50\n\t\t\t51\t52 \t53\t\t\t\t\t45\t46\t47\n***************************************/\n#define check Cubix[4] != Cubix[19];\n#assert Game() |= [] check;\n"
  },
  {
    "id": "peg",
    "name": "Peg Game",
    "matchtype": "loose match",
    "description": "This model implements the Peg Game, a classic single-player puzzle where pegs are removed through a series of valid jumps on a predefined board. Each time a peg is jumped, it is automatically removed. You can only remove pegs by jumping them.",
    "variable": "game_setting (between 1 and 9)",
    "implementation": "#define X -1;\n#define P 1;\n#define E 2;\n#define S 1; //sticky has the same value as P now.\n\n//===== Board 1 =========\n#define initEmptyX 3;\n#define initEmptyY 3;\n#define W 7;\n#define H 7;\nvar board[H][W] = \n\t\t  [X,X,P,P,P,X,X,\n           X,X,P,P,P,X,X,\n           S,S,P,P,P,P,P,\n           P,P,P,E,P,P,P,\n           S,S,P,P,P,P,P,\n           X,X,S,P,S,X,X,\n           X,X,S,P,S,X,X];\n    \nvar pegsCounter = 32;\n\n//four different ways of jumping\nUp(i, j) = [i-2>=0]([board[i-2][j]==E && board[i-1][j]== P]up{board[i-2][j] = P; board[i-1][j] = E; board[i][j] = E; pegsCounter--;} -> Game()); \nLeft(i, j) = [j-2>=0]([board[i][j-2]==E && board[i][j-1]== P]left{board[i][j-2] = P; board[i][j-1] = E; board[i][j] = E; pegsCounter--;} -> Game()); \nDown(i, j) = [i+2<H]([board[i+2][j] != X && board[i+2][j]==E && board[i+1][j]== P]down{board[i+2][j] = P; board[i+1][j] = E; board[i][j] = E; pegsCounter--;} -> Game());  \nRight(i, j) = [j+2<W]([board[i][j+2] != X && board[i][j+2]==E && board[i][j+1]== P]right{board[i][j+2] = P; board[i][j+1] = E; board[i][j] = E; pegsCounter--;} -> Game()); \n\n//if there is a peg in the cell, it makes four diffferent moves\nPeg(i,j) = [board[i][j]==P](Up(i,j) [] Left(i,j) [] Down(i,j) [] Right(i,j));\nGame() = []i:{0..H-1};j:{0..W-1}@ Peg(i,j);\n\n#define goal pegsCounter == 1 && board[initEmptyX][initEmptyY] == P;\n#assert Game() reaches goal;\n \n"
  },
  {
    "id": "vibe",
    "name": "Vibe Game Puzzle",
    "matchtype": "loose match",
    "description": "This Vibe Game Puzzle model represents a tile-matching puzzle game similar to real-world casual mobile games. The board is modeled as a 7\u00d76 grid, where each cell may hold one of several figure types or be empty. The system allows swapping adjacent non-empty figures to form lines of three or more matching figures, which are then automatically eliminated and shifted down. The game continues until a fixed number of moves (MAX_STEPS) is reached or all figures are cleared.",
    "variable": "",
    "implementation": "#import \"PAT.Lib.VibePuzzle\";\n\n#define ROWS 7;\n#define COLS 6;\n#define MAX_STEPS 6; //max steps allowed\n\n/*\n//Game Rule\nObjective: make all the figures disappear\nRule: \n1. figures will disappear when there are 3 or more adjecent same figures in a row or column.\n2. figures will automatically shift down if the space below is empty\n\nMove: swap any two adjecent figures (cannot swap figure with a empty space)\n\n\n//this model models the board\n\n0\t1\t2\t3\t4\t5\n6\t7\t8\t9\t10\t11\n12\t13\t14\t15\t16\t17\n18\t19\t20\t21\t22\t23\n24\t25\t26\t27\t28\t29\n30\t31\t32\t33\t34\t35\n36\t37\t38\t39\t40\t41\n\n*/\n\n#define em 0; //empty space\n#define t1 1;\n#define t2 2;\n#define t3 3;\n#define t4 4;\n#define t5 5;\n#define t6 6;\n\n//board is the only state variable to be tracked. all other variables are hidden or constant.\n\n//difficulty level: hard  : 6 steps\nvar board = [\nem,\tem,\tem,\tem,\tt1,\tem,\nem,\tem,\tem,\tem,\tt4,\tem,\nem,\tem,\tem,\tem,\tt6,\tem,\nem,\tem,\tem,\tt2,\tt5,\tt2,\nem,\tem,\tem,\tt3,\tt3,\tt5,\nem,\tem,\tem,\tt6,\tt6,\tt4,\nt1,\tt1,\tt2,\tt3,\tt4,\tt5 \n];\n\n\n/*\n//difficulty level: midle : 4 steps\nvar board = [\nem,\tem,\tem,\tem,\tem,\tem,\nt1,\tt4,\tem,\tem,\tem,\tem,\nt3,\tt4,\tem,\tem,\tem,\tem,\nt2,\tt3,\tem,\tem,\tem,\tem,\nt2,\tt1,\tem,\tem,\tem,\tem,\nt3,\tt4,\tem,\tem,\tem,\tem,\nt1,\tt2,\tem,\tem,\tem,\tem \n];\n*/\n\n/*\n//difficulty level: midle : 4 steps\nvar board = [\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tt2,\tt4,\tem,\tem,\tem,\nem,\tt4,\tt2,\tem,\tem,\tem,\nt1,\tt1,\tt4,\tem,\tem,\tem,\nt2,\tt4,\tt3,\tem,\tem,\tem,\nt1,\tt3,\tt2,\tt3,\tem,\tem \n];\n*/\n\n/*\n//difficulty level: easy : 2 steps\nvar board = [\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tem,\tem,\tem,\tem,\tem,\nem,\tem,\tem,\tem,\tt2,\tt3,\tt3,\nt2,\tt2,\tt1,\tt3,\tt1,\tt1 \n];\n*/\n\nvar step=0;\n\n//swap item i with the one on the left\nleft(i) = [step<MAX_STEPS && !call(isDead, board, ROWS, COLS) && i%COLS!=0 && board[i]!=em && board[i-1]!=em && board[i-1]!=board[i] ] \n\t\tswap_left.i{\n\t\t\tstep++;\n\t\t\t//swap\n\t\t\tvar temp = board[i];\n\t\t\tboard[i] = board[i-1];\n\t\t\tboard[i-1] = temp; \t\t\n\t\t\t\n\t\t\tboard = call(eliminate, board, ROWS, COLS);\n\t\t\t\n\t\t} -> Game();\n\t\n//swap item i with the one on the row above\nup(i) = [step<MAX_STEPS && !call(isDead, board, ROWS, COLS) && i>=COLS && board[i]!=em && board[i-COLS]!=em && board[i-COLS]!=board[i] ] \n\t\tswap_up.i{\n\t\t\tstep++;\n\t\t\t//swap\n\t\t\tvar temp = board[i];\n\t\t\tboard[i] = board[i-COLS];\n\t\t\tboard[i-COLS] = temp;\n\t\t\t\n\t\t\tboard = call(eliminate, board, ROWS, COLS);\n\t\t\t\n\t\t} -> Game();\n\n\nGame() = [] x:{0..ROWS*COLS-1}@( left(x) [] up(x)) ;\n\n\n#define goal \n\tboard[0]==em && board[1]==em && board[2]==em && board[3]==em && board[4]==em && board[5]==em && \n\tboard[6]==em && board[7]==em && board[8]==em && board[9]==em && board[10]==em && board[11]==em && \n\tboard[12]==em && board[13]==em && board[14]==em && board[15]==em && board[16]==em && board[17]==em && \n\tboard[18]==em && board[19]==em && board[20]==em && board[21]==em && board[22]==em && board[23]==em && \n\tboard[24]==em && board[25]==em && board[26]==em && board[27]==em && board[28]==em && board[29]==em && \n\tboard[30]==em && board[31]==em && board[32]==em && board[33]==em && board[34]==em && board[35]==em && \n\tboard[36]==em && board[37]==em && board[38]==em && board[39]==em && board[40]==em && board[41]==em ;\n\n\n#assert Game() reaches goal;"
  },
  {
    "id": "huarongdao",
    "name": "Hua Rong Dao (Klotski)",
    "matchtype": "loose match",
    "description": "This model represents Hua Rong Dao, a Chinese variant of the Klotski sliding block puzzle, based on the legendary escape of Cao Cao during the Battle of Red Cliffs. The version here models the 'Bi Yi Heng Kong' board configuration.",
    "variable": "version (please enter either 'general' or 'optimal' in the box below)",
    "implementation": "//The version of this Hua Rong Dao game is Bi Yi Heng Kong\n\n//The game goal is find a solution which is not required to have minimum number of steps .\n\n//This game huarongdao contains  4 bing (b1..b4) , 5 jiang (j5..j9) and 1 caocao (cc),2 space(sp)\n//noted that enumerate data values are from 0 such that sp=0,b1=1 etc.That feature is used in this mode.\n//j5:guanyu,j6:zhangfei,j7:zhaoyun,j8:machao,j9:huangzhongb1:bing,b2:ding,b3:zu,b4:yong\nenum {sp,b1,b2,b3,b4,j5,j6,j7,j8,j9,cc};\n\n//this array indicates jiang[i] is set either horizontally or vertically\n//1--vertical  0--horizontal 99-not used\nhvar jiang[11] = [99,99,99,99,99,1,1,1,1,1,99];\n\n//The board can be modified to check other stages and it is the only structure needed to change\n//one jiang occupys 2 position such that there are two j5.others are similar\n//99 is just a number which indicates the boundary. It can be changed to any number lager than 10\nhvar board[42] = [ 99,99,99,99,99,99,\n                   99,j7,j7,cc,cc,99,\n                   99,j8,j8,cc,cc,99,\n                   99,j6,j6,j5,j5,99,\n                   99,b1,b4,b2,j9,99,\n                   99,b3,sp,sp,j9,99,\n                   99,99,99,99,99,99 ];          \n                   \n\n//all moves are described in it\nvar seq[42] = [99(42)];\n\n//the two space position. Setting to 6 only for skip the Simluation(F6) checking \nhvar space1 = 6;\nhvar space2 = 6;\n\n//max steps which we allow PAT to try \n#define MAX_STEP 90;\n\n//standard game steps counter\nhvar counter=0;\nhvar last_move=0;\n\n#define UP 1;\n#define DOWN 2;\n#define LEFT 3;\n#define RIGHT 4;\n\nhvar last_direction = 0;\n\n//initialize the game\nInitial() = INIT{\n                    counter=0;\n                    last_move=0;\n\t                seq = board;\n\t                //set 7 to skip the boundary\n\t                var i = 7;\n\t                //initialize all jiang's placing directions(vertical or horizontal) and space positions\n\t                while(i<36)\n\t                {\n\t                \tif(seq[i]-seq[i-1]==0 && seq[i]!=cc && seq[i]!=sp && seq[i]!=99) jiang[seq[i]]=0;\n\t                \tif(seq[i]==sp)\n\t                \t{\n\t                \t    if(space1==6) space1 = i;\n\t                \t    else space2 = i;\n\t                \t}\n\t                    i++;                              \t\n\t                }\n                }->Skip;\n                \n\n//Bing's move\nBing(i) = [((seq[space1+6]==i) || (seq[space2+6]==i)) && !(last_move==i && last_direction==DOWN) && counter<=MAX_STEP]\n          bingup.i{\n                     if(seq[space1+6]==i)\n                     {seq[space1]=i;space1=space1+6;seq[space1]=sp}\n                     else\n                     {seq[space2]=i;space2=space2+6;seq[space2]=sp}\n                     if (last_move!=i) counter++;\n                     last_move=i;\n                     last_direction=UP;\n                   }->Bing(i)\n          []\n          [((seq[space1-6]==i) || (seq[space2-6]==i)) && !(last_move==i && last_direction==UP) && counter<=MAX_STEP]\n          bingdown.i{\n\t                    if(seq[space1-6]==i)\n\t                    {seq[space1]=i;space1=space1-6;seq[space1]=sp}\n\t                    else\n\t                    {seq[space2]=i;space2=space2-6;seq[space2]=sp}\n\t                    if (last_move!=i) counter++;\n                        last_move=i;\n                        last_direction=DOWN;\n\t                }->Bing(i)\n\t      []\n\t      [((seq[space1+1]==i) || (seq[space2+1]==i)) && !(last_move==i && last_direction==RIGHT) && counter<=MAX_STEP]\n\t      bingleft.i{\n\t                    if(seq[space1+1]==i)\n\t                    {seq[space1]=i;space1=space1+1;seq[space1]=sp}\n\t                    else\n\t                    {seq[space2]=i;space2=space2+1;seq[space2]=sp}\n\t                    if (last_move!=i) counter++;\n                        last_move=i;\n                        last_direction=LEFT;\n\t                }->Bing(i)\n\t      []\n\t      [((seq[space1-1]==i) || (seq[space2-1]==i)) && !(last_move==i && last_direction==LEFT) && counter<=MAX_STEP]\n\t      bingright.i{\n\t                     if(seq[space1-1]==i)\n\t                     {seq[space1]=i;space1=space1-1;seq[space1]=sp}\n\t                     else\n\t                     {seq[space2]=i;space2=space2-1;seq[space2]=sp}\n\t                     if (last_move!=i) counter++;\n                         last_move=i;\n                         last_direction=RIGHT;\n\t                 }->Bing(i);\n\n//Jiang's move\nJiang(i) = ifa(jiang[i]==0)\n           {\n           \t\t[seq[space1+6]==i && seq[space2+6]==i  && !(last_move==i && last_direction==DOWN) && counter<=MAX_STEP]\n           \t\tjiangup.i{\n           \t\t             seq[space1]=i;\n           \t\t             seq[space2]=i;\n           \t\t             space1=space1+6;\n           \t\t             space2=space2+6;\n           \t\t             seq[space1]=sp;\n           \t\t             seq[space2]=sp;\n           \t\t             if (last_move!=i) counter++;\n                             last_move=i;\n                             last_direction=UP;\n           \t\t         }->Jiang(i)\n           \t\t[]\n           \t\t[seq[space1-6]==i && seq[space2-6]==i && !(last_move==i && last_direction==UP) && counter<=MAX_STEP]\n           \t\tjiangdown.i{\n           \t\t               seq[space1]=i;\n           \t\t               seq[space2]=i;\n           \t\t               space1=space1-6;\n           \t\t               space2=space2-6;\n           \t\t               seq[space1]=sp;\n           \t\t               seq[space2]=sp;\n           \t\t               if (last_move!=i) counter++;\n                               last_move=i;\n                               last_direction=DOWN;\n           \t\t           }->Jiang(i)\t\n           \t\t[]\n           \t\t[((seq[space1+1]==i) || (seq[space2+1]==i)) && !(last_move==i && last_direction==RIGHT) && counter<=MAX_STEP]\n           \t\tjiangleft.i{\n           \t\t               if(seq[space1+1]==i)\n           \t\t               {seq[space1]=i;space1=space1+2;seq[space1]=sp}\n           \t\t               else\n           \t\t               {seq[space2]=i;space2=space2+2;seq[space2]=sp}\n           \t\t               if (last_move!=i) counter++;\n                               last_move=i;\n                               last_direction=LEFT;\n           \t\t           }->Jiang(i)\t\n           \t\t[]           \n           \t\t[((seq[space1-1]==i) || (seq[space2-1]==i)) && !(last_move==i && last_direction==LEFT) && counter<=MAX_STEP]\n           \t\tjiangright.i{\n           \t\t                if(seq[space1-1]==i)\n           \t\t                {seq[space1]=i;space1=space1-2;seq[space1]=sp}\n           \t\t                else\n           \t\t                {seq[space2]=i;space2=space2-2;seq[space2]=sp}\n           \t\t                if (last_move!=i) counter++;\n                                last_move=i;\n                                last_direction=RIGHT;\n           \t\t            }->Jiang(i)\n           }\n           else ifa(jiang[i]==1)\n           {\n                [((seq[space1+6]==i) || (seq[space2+6]==i)) && !(last_move==i && last_direction==DOWN) && counter<=MAX_STEP]\n                jiangup.i{\n                             if(seq[space1+6]==i)\n                             {seq[space1]=i;space1=space1+12;seq[space1]=sp}\n                             else\n                             {seq[space2]=i;space2=space2+12;seq[space2]=sp}\n                             if (last_move!=i) counter++;\n                             last_move=i;\n                             last_direction=UP;\n                         }->Jiang(i)\n                []\n                [((seq[space1-6]==i) || (seq[space2-6]==i)) && !(last_move==i && last_direction==UP)&& counter<=MAX_STEP]\n                jiangdown.i{\n                               if(seq[space1-6]==i)\n                               {seq[space1]=i;space1=space1-12;seq[space1]=sp}\n                               else\n                               {seq[space2]=i;space2=space2-12;seq[space2]=sp}\n                               if (last_move!=i) counter++;\n                               last_move=i;\n                               last_direction=DOWN;\n                           }->Jiang(i)\n                []\n                [seq[space1+1]==i && seq[space2+1]==i && !(last_move==i && last_direction==RIGHT) && counter<=MAX_STEP]\n                jiangleft.i{\n                               seq[space1]=i;\n           \t\t               seq[space2]=i;\n           \t\t               space1=space1+1;\n           \t\t               space2=space2+1;\n           \t\t               seq[space1]=sp;\n           \t\t               seq[space2]=sp;\n           \t\t               if (last_move!=i) counter++;\n                               last_move=i;\n                               last_direction=LEFT;\n           \t\t           }->Jiang(i)\t\n           \t\t[]\n           \t\t[seq[space1-1]==i && seq[space2-1]==i && !(last_move==i && last_direction==LEFT) && counter<=MAX_STEP]\n                jiangright.i{\n                                seq[space1]=i;\n           \t\t                seq[space2]=i;\n           \t\t                space1=space1-1;\n           \t\t                space2=space2-1;\n           \t\t                seq[space1]=sp;\n           \t\t                seq[space2]=sp;\n           \t\t                if (last_move!=i) counter++;\n                                last_move=i;\n                                last_direction=RIGHT;\n           \t\t            }->Jiang(i)\t\n           };\n\n//Caocao's move           \nCaocaoMove() = [seq[space1+6]==cc && seq[space2+6]==cc && !(last_move==cc && last_direction==DOWN) && counter<=MAX_STEP]\n           caocaoup{\n                       seq[space1]=cc;\n                       seq[space2]=cc;\n                       space1=space1+12;\n                       space2=space2+12;\n                       seq[space1]=sp;\n           \t\t       seq[space2]=sp;\n           \t\t       if (last_move!=cc) counter++;\n                       last_move=cc;\n                       last_direction=UP; \n                   }->CaocaoMove()\n           []\n           [seq[space1-6]==cc && seq[space2-6]==cc && !(last_move==cc && last_direction==UP) && counter<=MAX_STEP]\n           caocaodown{\n                         seq[space1]=cc;\n                         seq[space2]=cc;\n                         space1=space1-12;\n                         space2=space2-12;\n                         seq[space1]=sp;\n           \t\t         seq[space2]=sp;\n           \t\t         if (last_move!=cc) counter++;\n                         last_move=cc;\n                         last_direction=DOWN;\n                     }->CaocaoMove()\n           []\n           [seq[space1+1]==cc && seq[space2+1]==cc && !(last_move==cc && last_direction==RIGHT) && counter<=MAX_STEP]\n           caocaoleft{\n                         seq[space1]=cc;\n                         seq[space2]=cc;\n                         space1=space1+2;\n                         space2=space2+2;\n                         seq[space1]=sp;\n           \t\t         seq[space2]=sp;\n           \t\t         if (last_move!=cc) counter++;\n                         last_move=cc;\n                         last_direction=LEFT;\n                     }->CaocaoMove()\n           []\n           [seq[space1-1]==cc && seq[space2-1]==cc && !(last_move==cc && last_direction==LEFT) && counter<=MAX_STEP]\n           caocaoright{\n                          seq[space1]=cc;\n                          seq[space2]=cc;\n                          space1=space1-2;\n                          space2=space2-2;\n                          seq[space1]=sp;\n           \t\t          seq[space2]=sp;\n           \t\t          if (last_move!=cc) counter++;\n                          last_move=cc;\n                          last_direction=RIGHT;\n                      }->CaocaoMove();\n\n//10 entities synchronize                                        \nBingMove() = ||x:{b1..b4}@Bing(x);\nJiangMove() = ||x:{j5..j9}@Jiang(x);\nGame() = Initial();(BingMove()||JiangMove()||CaocaoMove());\n\n\n//caocao arrives the exit\n#define goal (seq[26]==cc && seq[27]==cc && seq[32]==cc && seq[33]==cc);\n\n//try to find out the best solution\n#assert Game() reaches goal with min(counter);\n\n\n\n"
  },
  {
    "id": "multi_register_1r_1w",
    "name": "Multi-valued Register Simulation with 1-Reader 1-Writer",
    "matchtype": "loose match",
    "description": "This model implements a multi-valued register simulation using a unary-encoded binary array, supporting one reader and one writer. The concrete implementation uses a binary array B to encode the current register value, where writers set the target index to 1 and clear lower indices, and the reader performs a two-phase scan to determine the most recent write. An abstract model represents the register as a single variable R, and the system validates correctness through bidirectional refinement checks between the concrete and abstract models.",
    "variable": "num_register_values (at least 3), implementation_type (either 'faulty' or 'correct'), and event_type (either 'tau' or 'explicit')",
    "implementation": "//shared binary array of size N\nvar B = [0,0,1];\n//register value used by the abstract model\nvar R = 2;\n//temporary value for abstract reader to stored the value read from register\nvar M = 0;\n\n////////////////The Concrete Implementation Model//////////////////\nReaders() = read_inv -> UpScan(0);\nUpScan(i) = if(B[i] == 1) { DownScan(i - 1, i) } else { UpScan(i + 1) };\nDownScan(i, v) =\n\t\tif(i >= 0) {\n\t\t\tif(B[i] == 1) { DownScan(i - 1, i) } else { DownScan(i - 1, v) }\n\t\t} else {\n\t\t\tread_res.v -> Readers()\n\t\t};\n\nWriter(i) = write_inv.i -> tau{B[i] = 1;} -> WriterDownScan(i-1);\nWriterDownScan(i) = if(i >= 0) { tau{B[i] = 0;} -> WriterDownScan(i-1) } else { write_res -> Skip };\n\nWriters() = (Writer(0)[]Writer(1)[]Writer(2)); Writers();\nRegister() = Readers() ||| Writers();\n\n////////////////The Abstract Specification Model//////////////////\nReadersAbs() = read_inv -> tau{M=R;} -> read_res.M -> ReadersAbs();\n\nWriterAbs(i) = write_inv.i -> tau{R=i;} -> write_res -> Skip;\nWritersAbs() = (WriterAbs(0)[]WriterAbs(1)[]WriterAbs(2)); WritersAbs();\n\nRegisterAbs() = ReadersAbs() ||| WritersAbs();\n\n////////////////The Properties//////////////////\n#assert Register() refines RegisterAbs();\n#assert RegisterAbs() refines Register();"
  },
  {
    "id": "multi_register_mr",
    "name": "Multi-valued Register Simulation with Multiple Readers",
    "matchtype": "loose match",
    "description": "This model implements a multi-valued register simulation with multiple readers, where each reader independently scans a shared unary-encoded binary array B to determine the most recent value written by a writer. Each reader performs a two-phase scan (up and down) to ensure a consistent view of the register. Writers update the register by setting a target index to 1 and clearing all lower indices. An abstract model represents the register with a shared value R and per-reader temporary variables M[id]. Bidirectional refinement checks validate that the concrete implementation correctly simulates the abstract multi-reader behavior.",
    "variable": "num_register_values (at least 3), num_readers (at least 1), and implementation_type (either 'faulty' or 'correct')",
    "implementation": "#define N 2;\n\n//shared binary array of size N\nvar B = [0,0,1];\n//register value used by the abstract model\nvar R = 2;\n//temporary value for abstract reader to stored the value read from register\nvar M[N];\n\n////////////////The Concrete Implementation Model//////////////////\nReaders(id) = read_inv.id -> UpScan(0, id);\nUpScan(i, id) =  if(B[i] == 1) { DownScan(i - 1, i, id) } else { UpScan(i + 1, id) };\nDownScan(i, v, id) =\n\t\tif(i >= 0) {\n\t\t\tif(B[i] == 1) { DownScan(i - 1, i, id) } else { DownScan(i - 1, v, id) }\n\t\t} else {\n\t\t\tread_res.id.v -> Readers(id)\n\t\t};\n\nWriter(i) = write_inv.i -> tau{B[i] = 1;} -> WriterDownScan(i-1);\nWriterDownScan(i) = if(i >= 0 ) { tau{B[i] = 0;} -> WriterDownScan(i-1) } else { write_res -> Skip } ;\n\nWriters() = (Writer(0)[]Writer(1)[]Writer(2)); Writers();\nRegister() = (|||x:{0..N-1}@Readers(x)) ||| Writers();\n////////////////The Abstract Specification Model//////////////////\nReadersAbs(id) = read_inv.id -> tau{M[id]=R;} -> read_res.id.M[id] -> ReadersAbs(id);\n\nWriterAbs(i) = write_inv.i -> tau{R=i;} -> write_res -> Skip;\nWritersAbs() = (WriterAbs(0)[]WriterAbs(1)[]WriterAbs(2)); WritersAbs();\n\nRegisterAbs() = (|||x:{0..N-1}@ReadersAbs(x))||| WritersAbs();\n////////////////The Properties//////////////////\n#assert Register() refines RegisterAbs();\n#assert RegisterAbs() refines Register();"
  },
  {
    "id": "concurrent_stack",
    "name": "Concurrent Stack Implementation",
    "matchtype": "loose match",
    "description": "This model implements a concurrent stack with multiple processes, where each process can perform push or pop operations on a shared stack of bounded size. The concrete implementation uses a shared head pointer H, with local copies HL[i] for each process to perform compare-and-set style updates, allowing for retry if a concurrent modification is detected. The abstract model uses a simplified pointer HA and local heads HLA[i] to reflect atomic stack behavior without contention. Bidirectional refinement checks ensure that the concurrent implementation correctly simulates the abstract atomic stack behavior under concurrent access.",
    "variable": "num_processes (at least 2), stack_length (at least 1), and event_type (either 'tau' or 'explicit')",
    "implementation": "////number of processes\n#define N 2;\n//stack size\n#define SIZE 2;\n\n//shared head pointer for the concrete implementation\nvar H = 0;\n//local variable to store the temporary head value\nvar HL[N];\n\n//shared head pointer for the abstract implementation\nvar HA = 0;\n//local variable to store the temporary head value\nvar HLA[N];\n\n////////////////The Concrete Implementation Model//////////////////\nPushLoop(i) = tau{HL[i]=H;} -> (\n\tifa (HL[i] == H) {\n\t\ttau{if(H < SIZE) {H = H+1;} HL[i]=H;} -> tau -> push_res.i.HL[i] -> Skip\n\t} else {\n\t\tPushLoop(i)\n\t});\n\nPopLoop(i) = tau{HL[i]=H;} -> \n\t(if(HL[i] == 0) {\n\t\tpop_res.i.0 -> Skip \n\t} else {\n\t\t(ifa(HL[i] != H) { PopLoop(i) } else { tau{H = H-1; HL[i]=H;} -> tau -> pop_res.i.(HL[i]+1) -> Skip\n\t\t})\n\t});\n\nProcess(i) = (push_inv.i -> PushLoop(i)[] pop_inv.i -> PopLoop(i));Process(i);\nStack() = |||x:{0..N-1}@Process(x);\n\n////////////////The Abstract Specification Model//////////////////\nPushAbs(i) = push_inv.i -> tau{if(HA < SIZE) {HA = HA+1;}; HLA[i]=HA;} -> push_res.i.HLA[i] -> Skip;\n\nPopAbs(i) = pop_inv.i ->\n\t(ifa(HA == 0) {\n\t\ttau-> pop_res.i.0 -> Skip \n\t} else {\n\t\t tau{HA = HA -1; HLA[i]=HA;} -> pop_res.i.(HLA[i]+1) -> Skip\n\t});\n\nProcessAbs(i) = (PushAbs(i)[]PopAbs(i));ProcessAbs(i);\n\nStackAbs() = |||x:{0..N-1}@ProcessAbs(x);\n\n////////////////The Properties//////////////////\n#assert Stack() refines StackAbs();\n#assert StackAbs() refines Stack();"
  },
  {
    "id": "concurrent_stack_linear",
    "name": "Concurrent Stack Linearization Point Implementation",
    "matchtype": "loose match",
    "description": "This model implements a Concurrent Stack Linearization Point Implementation, where multiple processes access a bounded stack using inline linearization logic. Each process locally caches the shared head pointer H into HL[i], and proceeds only if the snapshot matches the current state\u2014ensuring a consistent linearization point before modifying the stack. The push and pop operations are guarded and update the shared pointer directly without result variables or separate response channels. This design contrasts with other concurrent stack models by embedding linearization decisions directly into the control flow, minimizing auxiliary communication. An abstract specification models the stack with a shared pointer HA, and bidirectional refinement checks confirm that the implementation conforms to atomic stack semantics.",
    "variable": "num_processes (at least 2) and stack_length (at least 1)",
    "implementation": "////number of processes\n#define N 2;\n//stack size\n#define SIZE 2;\n\n//shared head pointer for the concrete implementation\nvar H = 0;\n//local variable to store the temporary head value\nvar HL[N];\n//shared head pointer for the abstract implementation\nvar HA = 0;\n\n////////////////The Concrete Implementation Model//////////////////\nPush(i) = \n\t    tau{HL[i]=H;} -> \n\t    ifa (HL[i] == H) {\n\t\t    push.i.(H+1){if(H < SIZE) {H = H+1;}} -> Skip\n\t    } else {\n\t    \ttau -> Push(i)\n\t  \t};\n\nPop(i) =\n\t\t\ttau{HL[i]=H;} -> \n\t\t\tifa(H == 0) {\n\t\t\t\tpop.i.0 -> Skip \n\t\t\t} else {\n\t\t\t\ttau-> ifa(HL[i] != H) {tau -> Pop(i) } else {pop.i.H{if(H > 0) {H = H -1;}} -> Skip}\n\t\t\t};\n\nProcess(i) = (Push(i)[]Pop(i));Process(i);\nStack() = (|||x:{0..N-1}@Process(x));\n\n////////////////The Abstract Specification Model//////////////////\nPushAbs(i) = push.i.(HA + 1) {if(HA < SIZE) {HA = HA+1;}} -> Skip;\nPopAbs(i) = pop.i.HA{if(HA > 0) {HA = HA -1;}} -> Skip;\n\nProcessAbs(i) = (PushAbs(i)[]PopAbs(i));ProcessAbs(i);\n\nStackAbs() = (|||x:{0..N-1}@ProcessAbs(x));\n\n////////////////The Properties//////////////////\n#assert Stack() refines StackAbs();\n#assert StackAbs() refines Stack();"
  },
  {
    "id": "mailbox",
    "name": "The Mailbox Problem",
    "matchtype": "loose match",
    "description": "This model implements the Mailbox Problem, where one process (the Postman) delivers messages and another process (the Wife) checks and removes them, ensuring that no message is lost or duplicated. The concrete implementation uses timestamp and counter arrays to simulate coordination across bounded rounds, with comparisons and status propagation between rounds to track successful delivery and acknowledgment. The abstract model simplifies this behavior using a counter (CountA) to track delivered messages and a flag (FlagL) for decision logic. Bidirectional refinement checks confirm that the concrete protocol faithfully implements the abstract mailbox semantics under concurrent operations.",
    "variable": "num_operations (at least 2), implementation_type (either 'waitfree' or 'non_blocking'), and optimization_type (either 'no_optimization' or 'with_optimization')",
    "implementation": "#import \"PAT.Lib.Example\";\n\n#define EQ 0;\n#define NEQ 1;\n \n#define BOTTOM  0;\n#define UNKNOWN  1;\n#define SUCCESS  2;\n#define DONE  3;\n \n//bounded number of Rounds\n#define ROUND 4;\n#define MaxROUND 2;\n \nvar A0TS[ROUND];\nvar A0C[ROUND];\n \nvar A1TS[ROUND];\nvar A1C[ROUND];\n \nvar B0[ROUND];\nvar B1[ROUND];\n \nvar TS = [1, 1];\nvar Rel = [0, 0];\n \nvar Counter[2];\nvar Rounds[2];\nvar Otherc[2];\nvar OutvalueTS[2];\nvar OutvalueC[2];\nvar Outcome[2];\nvar TSL[2];\nvar RelL[2];\n \nvar NextTS = [2,2];\nvar Otherts = [1,1];\nvar TSC = [1, 1];\n \nvar rnd0 = 0;\nvar rnd1 = 0;\n \n////////////////The Concrete Implementation Model//////////////////\n//process 0: postman\nPostman(i) = [i < MaxROUND](deliver_inv -> tau{Counter[0] = Counter[0] + 1;} -> (Compare(0); deliver_res -> Postman(i+1)));\n \nCompare(i) = tau{Outcome[i] = UNKNOWN;} -> \n   (CompareLoop(i); \n    (if(Counter[i] != Otherc[i]) {\n         tau{TS[i] = TSC[i]; Rel[i] = NEQ;} -> Skip\n     } else { \n         tau{TS[i] = TSC[i]; Rel[i] = EQ;} -> Skip\n     })\n   );\n \nCompareLoop(i) = if (Outcome[i] == SUCCESS) { Skip } else {\n                  tau{Rounds[i] = Rounds[i] + 1;} -> tau{TSC[i] = NextTS[i];} -> Sussus(i);\n                        (if(OutvalueC[i] != BOTTOM) { \n                             tau{Otherts[i] = OutvalueTS[i];} -> tau{Otherc[i] = OutvalueC[i];} -> Skip\n                        } else {\n                             Skip\n                        });\n                        tau{NextTS[i] = call(dominate, Otherts[i], TS[1-i]);} -> CompareLoop(i)\n                  };\n \nSussus(i) = if(i == 0) { Sussus0() } else { Sussus1() };\n \nSussus0() = tau{rnd0 = Rounds[0] - 1; A0TS[rnd0] = TSC[0]; A0C[rnd0] = Counter[0];} -> tau{OutvalueTS[0] = A1TS[rnd0]; OutvalueC[0] = A1C[rnd0];} ->\n    (if(OutvalueC[0] == BOTTOM) {\n        tau{Outcome[0] = SUCCESS;} -> Skip\n    } else {\n        tau{B0[rnd0] = DONE;} ->\n            (if(B1[rnd0] == BOTTOM) {\n                tau{Outcome[0] = UNKNOWN;} -> Skip\n             } else {\n                tau{Outcome[0] = SUCCESS;} -> Skip\n             })\n    });\n \nSussus1() = tau{rnd1 = Rounds[1] - 1; A1TS[rnd1] = TSC[1]; A1C[rnd1] = Counter[1];} -> tau{OutvalueTS[1] = A0TS[rnd1]; OutvalueC[1] = A0C[rnd1];} ->\n    (if(OutvalueTS[1] == BOTTOM) {\n        tau{Outcome[1] = SUCCESS;} -> Skip\n    } else {\n        tau{B1[rnd1] = DONE;} ->\n            (if(B0[rnd1] == BOTTOM) {\n                tau{Outcome[1] = UNKNOWN;} -> Skip\n             } else {\n                tau{Outcome[1] = SUCCESS;} -> Skip\n             })\n    });\n \n//process 1: wife\nCheck() = check_inv -> tau{TSL[0] = TS[0]; RelL[0] = Rel[0];} -> tau{TSL[1] = TS[1]; RelL[1] = Rel[1];} ->\n   (if(call(mailorder, TSL[0], TSL[1])) {\n           (if(RelL[0] == EQ) {\n               check_resf -> Check()\n           } else {\n               check_rest -> Remove()\n           })\n    } else {\n           (if(RelL[1] == EQ) {\n               check_resf -> Check()\n           } else {\n               check_rest -> Remove()\n           })\n    });\n \nRemove() = remove_inv -> tau{Counter[1] = Counter[1] + 1;} -> (Compare(1); remove_res -> Skip);\nWife(i) = [i < MaxROUND](Check(); Wife(i+1));\nMailbox() = Postman(0) ||| Wife(0);\n \n////////////////The Abstract Specification Model//////////////////\nvar FlagL = 0;\nvar CountA = 0;\n \nPostmanAbs(i) = [i < MaxROUND](deliver_inv -> deliver{CountA = CountA + 1;} -> deliver_res -> PostmanAbs(i+1));\n \nCheckAbs() = check_inv -> check{FlagL = CountA;} -> (if(FlagL > 0) { check_rest -> RemoveAbs() } else { check_resf -> CheckAbs() });\nRemoveAbs() = remove_inv -> remove{CountA = CountA - 1;} -> remove_res -> Skip;\nWifeAbs(i) = [i < MaxROUND](CheckAbs(); WifeAbs(i+1));\n \nMailboxAbs() = (PostmanAbs(0) ||| WifeAbs(0)) \\{deliver, check, remove};\n \n////////////////The Properties//////////////////\n#assert Mailbox() refines MailboxAbs();\n#assert MailboxAbs() refines Mailbox();"
  },
  {
    "id": "snzi",
    "name": "SNZI: Scalable NonZero Indicators",
    "matchtype": "loose match",
    "description": "This model implements the Scalable NonZero Indicators (SNZI) protocol, which tracks whether at least one process is present in a system using a tree-based hierarchical structure of SNZI nodes. The concrete model uses LL/SC-like primitives, CAS-based coordination, and local state for each process to manage arrival and departure operations across both hierarchical and root nodes. A global presence indicator (I) is maintained based on updates at the root. The abstract model simplifies this to a surplus counter and a Boolean indicator. Bidirectional refinement checks confirm that the optimized, scalable tree-structured protocol preserves the correctness of the abstract presence semantics.",
    "variable": "num_processes (at least 2), num_treenodes (at least 1), num_operations (at least 1), model_type (either 'detailed' or 'compact')",
    "implementation": "//This model is for \"SNZI: Scalable NonZero Indicators\"\n\n//number of processes\n#define PRO_SIZE 2;\n\n// number of nodes\n#define NODE_SIZE 2;\n\n\n//------------------------------shared variable------------------------------\n//Since SNZI algorithm is organized as a rooted tree of SNZI objects, we create a NODE_SIZE array of Node objects.\n//The root is the first element of the array,  and for 0 < i < NODE_SIZE, the parent of the ith node is the (i-1)/2th node.\n\n//array of shared variables of nodes (including hierarchical and root nodes), \n//each nodes has its own local copy. so there are NODE_SIZE copies \nvar node_c[NODE_SIZE];  //the original X.c\nvar node_v[NODE_SIZE];  //the original X.v\n\n\nvar node_a = 0;    //the origina X.a for the root, i.e. the first element of the array\n\n//presence indicator\nvar I = 0;\n\n\n//------------------------------local variable------------------------------\n\n//array of local variables which are used in the corresponding operations of nodes when a process arrives at or departs from nodes, \n// i.e. representing x in the original algorithm\n//as there may be N processes visiting one node concurrently, there could be NODE_SIZE * PRO_SIZE local variables\n//this is a variant of 2-dimention array. for node i, the local variable of process j\n//can be calculated by (i * PRO_SIZE + j)\nvar cc[NODE_SIZE * PRO_SIZE];\nvar vv[NODE_SIZE * PRO_SIZE];\n\n//aa is the local variable of root node, so there will at most PRO_SIZE copies because only at most\n//PRO_SIZE processes can visit root node at the same time.\nvar aa[PRO_SIZE];\n\n\n//another local variables of root node, representing x' in the original algorithm\n//As above, only at most PRO_SIZE processes can visit the root node concurrently,\n//so each array contains PRO_SIZE elements.\nvar rootc[PRO_SIZE];\nvar roota[PRO_SIZE];\nvar rootv[PRO_SIZE];\n\n\n//other local variables of hierarchical SNZI node\n//for each such node, PRO_SIZE processes can visit it simultoneously, \n//so the total number of each local varaible should be NODE_SIZE * PRO_SIZE\nvar succ[NODE_SIZE * PRO_SIZE];    //the original succ in the Arrive operation \nvar undoArr[NODE_SIZE * PRO_SIZE]; //the original undoArr in the Arrive operation\n\n//for LL-SC primitive\nvar updateCounter;\nvar pro_counter[PRO_SIZE];\n\n\n//------------------------------The Concrete Implementation Model------------------------------\n//Single Entry of Arrival and Departure operations on any nodes\nArriveImpl(process, node) = arrive_inv.process -> ArriveGeneral(process,node); arrive_res.process -> Skip;\n\nDepartImpl(process, node) = depart_inv.process -> DepartGeneral(process,node);depart_res.process -> Skip;\n\nArriveGeneral(process, node) = ifa (node == 0) {ArriveRoot(process)} else { Arrive(process, node)};\n\nDepartGeneral(process,node) = ifa (node == 0) {DepartRoot(process)} else {Depart(process,node)};\n\n//------------------------------start - this part is for root node------------------------------\n//Arrival on root node\nArriveRoot(process) =  t {cc[process] = node_c[0]; aa[process] = node_a; vv[process] = node_v[0];} // x <- Read(X)\n\t\t\t\t -> Repeat(process);Until(process);\n\nRepeat(process) = if (cc[process] == 0) \n\t             {   // if x.c = 0 \n\t\t\t\t\t     t {rootc[process] = 1; roota[process] = 1; rootv[process] = vv[process] + 1;} -> Skip //  x'<- (1, true, x.v + 1)\n\t\t\t\t }         \n\t             else \n\t             {\n\t\t\t\t\t     t {rootc[process] = cc[process] + 1; roota[process] = aa[process]; rootv[process] = vv[process];} -> Skip // x'<-(x.c+1, x.a, x.v)\n\t             };\n\nUntil(process) = ifa (cc[process] == node_c[0] && aa[process] == node_a && vv[process] == node_v[0])  //  until CAS(X, x, x')\n\t\t\t\t   {           \n\t\t\t\t\t     t {node_c[0] = rootc[process]; node_a = roota[process]; node_v[0] = rootv[process];} -> Write(process)   \n\t\t\t\t   }\n\t\t\t\t   else {\n\t\t\t\t\t     ArriveRoot(process)\n\t\t\t\t   };\n\nWrite(process) = if (roota[process] == 1) { // if x'.a then\n\t\t\t\t         t {I = 1; updateCounter = updateCounter + 1;} -> CAS(process)   // Write(I, true)\n\t\t\t\t      }\n\t\t\t\t      else {\n\t\t\t\t         Skip\n\t\t\t\t      };\n\t\t\t\t  \nCAS(process) = ifa (node_c[0] == rootc[process] && node_a == roota[process] && node_v[0] == rootv[process]) { //CAS(X,x',(x'.c, false, x'.v))\n\t\t\t\t         t {node_c[0] = rootc[process]; node_a = 0; node_v[0] = rootv[process];} -> Skip\n\t\t\t\t      }\n\t\t\t\t      else {\n\t\t\t\t         Skip\n\t\t\t\t      };\n\n\n//Departure from root node\nDepartRoot(process) =  t {cc[process] = node_c[0]; aa[process] = node_a; vv[process] = node_v[0];} -> line15(process);  \nline15(process) = ifa (cc[process] == node_c[0] && aa[process] == node_a && vv[process] == node_v[0]) //if CAS(X, x, (x.c - 1, false, x.v))\n\t\t\t\t   { \n\t\t\t\t\t     t {node_c[0] = cc[process] - 1; node_a = 0; node_v[0] = vv[process];} -> l151(process)\n\t\t\t\t   }\n\t\t\t\t   else { DepartRoot(process)};\n\t\t\t\t   \nl151(process) = if (cc[process] > 1) {Skip}  \n\t\t\t\t   else {DepartRootLoop(process) };\n\t\t\t\t   \nDepartRootLoop(process) = t { pro_counter[process] = updateCounter;} // LL(I)\n\t\t\t\t       -> \n\t\t\t\t       if (vv[process] != node_v[0]) { Skip}\n\t\t\t\t       else\n\t\t\t\t       {\n\t\t\t\t           ifa ( pro_counter[process] != updateCounter) {t -> DepartRootLoop(process)}\n\t\t\t\t           else {\n\t\t\t\t              t {I = 0; updateCounter = updateCounter + 1;} -> Skip\n\t\t\t\t           }\n\t\t\t\t       }\n\t\t\t\t       ;\n//------------------------------end - this part is for root node------------------------------\n\n\n//------------------------------start - hierarchical SNZI node------------------------------\n//Arrival of hierarchical SNZI node\nArrive(process, node) = t {succ[node * PRO_SIZE + process] = 0;} \n\t\t\t\t     -> t {undoArr[node * PRO_SIZE + process] = 0;} \n\t\t\t\t     -> ArriveLoop1(process, node); ArriveLoop2(process, node); Skip;\n\nArriveLoop1(process, node) = if (succ[node * PRO_SIZE + process] == 0) {\n\t\t\t\t\t\t     t {cc[node * PRO_SIZE + process] = node_c[node]; vv[node * PRO_SIZE + process] = node_v[node];}\n\t\t\t\t\t\t     -> ArriveCase1(process, node)\n\t\t\t\t     } else {Skip};\n\t\t\t\t     \n//Because 1/2 cannot be expressed in pat, all values of x.c and X.c on hierarchical node will be twice as the original values.\nArriveCase1(process, node) = if (cc[node * PRO_SIZE + process] > 1 ) { //if x.c >= 1 then\n\t\t\t\t\t     l2(process, node); ArriveCase2(process, node)\n\t\t\t\t     }\n\t\t\t\t     else {\n\t\t\t\t        ArriveCase2(process, node)\n\t\t\t\t     };\n\t\t\t\t\t\nl2(process, node) = ifa (cc[node * PRO_SIZE + process] == node_c[node] && vv[node * PRO_SIZE + process] == node_v[node]) { //if CAS(X, x, (x.c + 1, x.v)) then \n\t\t\t\t         t {node_c[node] = cc[node * PRO_SIZE + process] + 2; node_v[node] = vv[node * PRO_SIZE + process];} \n\t\t\t\t         -> t {succ[node * PRO_SIZE + process] = 1;} -> Skip\n\t\t\t\t     }\n\t\t\t\t     else { t -> Skip};\n\t\t\t\t\nArriveCase2(process, node) = if (cc[node * PRO_SIZE + process] == 0) { // if x.c = 0 then\n\t\t\t\t         l3(process, node); ArriveCase3(process, node)\n\t\t\t\t     }\n\t\t\t\t     else {\n\t\t\t\t         ArriveCase3(process, node)\n\t\t\t\t     };\n\t\t\t\t\t\nl3(process, node) = ifa (cc[node * PRO_SIZE + process] == node_c[node] && vv[node * PRO_SIZE + process] == node_v[node]) { // if CAS(X, x, (1 / 2, x.v + 1)) then\n\t\t\t\t         t {node_c[node] = 1; node_v[node] = vv[node * PRO_SIZE + process] + 1;} \n\t\t\t\t         -> t {succ[node * PRO_SIZE + process] = 1;}\n\t\t\t\t         -> t {cc[node * PRO_SIZE + process] = 1; vv[node * PRO_SIZE + process] = vv[node * PRO_SIZE + process] + 1;} \n\t\t\t\t         -> Skip\n\t\t\t\t     }\n\t\t\t\t     else { t -> Skip};\n\n//if x.c = 1/2 then\nArriveCase3(process, node) = if (cc[node * PRO_SIZE + process] == 1) {  \n\t\t\t\t         ArriveGeneral(process, (node - 1)/2); l5(process,node)\n\t\t\t\t     }\n\t\t\t\t     else\n\t\t\t\t     {\n\t\t\t\t         ArriveLoop1(process, node)\n\t\t\t\t     };\n\nl5(process, node) = ifa (cc[node * PRO_SIZE + process] == node_c[node] && vv[node * PRO_SIZE + process] == node_v[node]) {\n\t\t\t\t         t {node_c[node] = 2; node_v[node] = vv[node * PRO_SIZE + process];} -> ArriveLoop1(process, node)\n\t\t\t\t     }\n\t\t\t\t     else {\n\t\t\t\t         t -> t {undoArr[node * PRO_SIZE + process] = undoArr[node * PRO_SIZE + process] + 1;} -> ArriveLoop1(process, node)\n\t\t\t\t     };\n\t\t\t\t \nArriveLoop2(process, node) = if (undoArr[node * PRO_SIZE + process] > 0) {\n\t\t\t\t         DepartGeneral(process, (node - 1)/2);\n\t\t\t\t         t {undoArr[node * PRO_SIZE + process] = undoArr[node * PRO_SIZE + process] - 1;} \n\t\t\t\t         -> ArriveLoop2(process, node)\n\t\t\t\t     }\n\t\t\t\t     else { Skip};\n\n//Departure of hierarchical SNZI node\nDepart(process, node) = t {cc[node * PRO_SIZE + process] = node_c[node]; vv[node * PRO_SIZE + process] = node_v[node];} \n\t\t\t\t   -> l8(process, node); Skip;\n\t\t\t\t\t\t\nl8(process, node) = ifa (cc[node * PRO_SIZE + process] == node_c[node] && vv[node * PRO_SIZE + process] == node_v[node]) { //if CAS(X, x, (x.c - 1, x.v)) then\n\t\t\t\t         t {node_c[node] = cc[node * PRO_SIZE + process] - 2; node_v[node] = vv[node * PRO_SIZE + process];} \n\t\t\t\t         -> l9(process, node)\n\t\t\t\t     }\n\t\t\t\t     else { t -> Depart(process, node)};\n\n// if x.c = 1 then call parent.Depart\t\t\nl9(process, node) = if (cc[node * PRO_SIZE + process] == 2) {\n\t\t\t\t         DepartGeneral(process, (node - 1)/2);   Skip\n\t\t\t\t     }\n\t\t\t\t     else {\n\t\t\t\t         Skip\n\t\t\t\t     };\n//------------------------------end - hierarchical SNZI node------------------------------\n\n\nProcess(i, j) = [j <2] ( [] x:{0..NODE_SIZE - 1} @ (ArriveImpl(i, x); DepartImpl(i, x)); Process(i, j+1)); \n\nQuery() = query.I -> Query();\n\nSNZI() = (||| x:{0..PRO_SIZE - 1} @ Process(x, 0)) \\{t} ||| Query();\n\n\n//------------------------------Abstract Specification Model------------------------------\n\n//shared variable\nvar surplus = 0;\nvar indicator = 0;\n\nArriveAbs(i) = arrive_inv.i -> t {surplus = surplus + 1; indicator = 1;} -> arrive_res.i -> Skip;\n\nDepartAbs(i) = depart_inv.i -> t {surplus = surplus - 1;\n\t\t\t\t   if (surplus == 0) {indicator = 0;} } -> depart_res.i -> Skip; \n\nProcessAbs(i, j) = [j <2] (ArriveAbs(i); DepartAbs(i); ProcessAbs(i, j+1));\n\nQueryAbs() = query.indicator -> QueryAbs();\n\nSNZIAbs() = (||| x:{0..PRO_SIZE-1} @ ProcessAbs(x, 0)) \\ {t} ||| QueryAbs();\n\n\n#assert SNZI() refines SNZIAbs();\n#assert SNZIAbs() refines SNZI();\n"
  },
  {
    "id": "liftingtruck",
    "name": "Lifting Truck System",
    "matchtype": "loose match",
    "description": "This model implements a Lifting Truck System consisting of three interconnected lifts coordinated through button controls and a shared communication bus. Each lift can initiate operations via four control buttons (up, down, setref, and axis), with behaviors dependent on whether operations are local (setref pressed) or global (synchronized across all lifts). The system operates in two phases: a startup phase, where each lift assigns itself a position and discovers the number of active lifts, and a normal operation phase, where lifts take turns initiating movement and broadcasting their state. Communication and coordination are handled via a CAN-style bus protocol using relay-based message delivery. The model enforces correctness via detailed verification properties ensuring synchronized movement, mutual exclusion, relay safety, correct positioning, and eventual responsiveness. Refinement checks confirm that the system allows both ordered and arbitrary lift activations and movements.",
    "variable": "",
    "implementation": "/* ****************** Lifting Truck System ******************\n** The lift system studied in this model consists of 3 lifts. \n** The system is operated by means of buttons on the lifts.\n** There are four such buttons on each lift: up, down, setref and axis.\n** If the up or down button of a certain lift is pressed, all the lifts of the system should go up, respectively down. \n** If the up or down button is pressed together with setref, only one lift (the one of whichthe buttons are pressed) should go up or down. \n**\n** Behavior description:\n**\n** -- STARTUP phase\n** -- A. The SETREF button of a station might be pressed\n** -- \t1. it stores that it has pos 1,\n** -- \t2. it adopts the STARTUP state,\n** -- \t3. it closes its relay,\n** -- \t4. it broadcasts a STARTUP message,\n** -- \t5. it opens its relay,\n** -- \t6. { if it receives an another startup message it stores the pos of the sender of that message as the number of stations in the network,\n**\t       { if it receives a standby message it adopts the standby state (if the station has pos 2 it will in addition initiate normal operation by broadcasting its state).\n**\n** -- Normal operation phase\n** -- During normal operation, the \\fist station (with pos 1) broadcasts its state\n\t and height, then the next station broadcasts its state and height and so on, until the last station has\n\t broadcast its state and height after which the \\fist station starts again.\n**/\n \n#import \"PAT.Lib.List\";\n#define STARTUP 0;                // 5 types of messages of station \n#define STANDBY 1;\n#define UP 2;\n#define DOWN 3;\n#define SYNC 4;\n#define NIL 0;\n#define ST 3;                    // number of stations in the network\n \n/* Global variables */\nvar suc[ST+1] = [0, 2, 3, 1]; \t// suc[i]: the id of the next lift of lift i\nvar pre[ST+1] = [0, 3, 1, 2];\t// pre[i]: the id of the previous lift of lift i\n \nvar pos[ST+1]=[NIL(ST+1)]; \t\t// pos[i]: pos obtained by station i\nvar num[ST+1] = [NIL(ST+1)];    // num[i]: number of stations in the network known by station i\nvar state[ST+1];                // STARTUP, STANDBY, UP, DOWN, SYNC\nvar pressed_SETREF[ST+1];        // pressed_SETREF[i] = 1: button SETREF of station i is being pressed\n                                // pressed_SETREF[i] = 0: button SETREF of station i is being released\nvar active[ST+1];               // number of active station\n \nvar<List> R;                    // list of CLOSED relays, initially it is empty\n \nvar relay_opened;               // the latest opened relay\nvar relay_closed;               // the latest closed relay\n \nvar msg_id;                     // station msg_id sends the msg\nvar msg_pos;                    // station with pos msg_pos sends the msg\nvar msg_state;                  // msg has state msg_state\n \nvar is_setref_pressed;         // 0: no lift has pressed button SETREF; 1: there is some lift with button SETREF pressed\nvar has_active_station;         // 0: no lift is in active state; 1: there is some lift in active state\n \n/*----------------------------Bus process-----------------------------*/\n/* The bus implemented a CAN protocol. \n** The CAN protocol allows several stations to claim the bus at the same time. \n** However, in the lift system, the stations are programmed in such a way that (during normal operation) the stations take\n** turns claiming the bus. They claim the bus in a fixed order, specified by pre[] & suc[] in this model.\n*/\nBus() =\treq ->  (stob_init -> Deliver(); open_relay -> update_r_list{R.Remove(relay_opened);} -> rel -> Bus()\n\t\t\t [] stob -> Deliver(); rel -> Bus()\n\t\t\t [] open_relay -> update_r_list{R.Remove(relay_opened);} -> rel -> Bus()\n\t\t\t [] close_relay -> update_r_list{R.Add(relay_closed);} -> rel -> Bus()\n\t\t\t [] rel -> Bus());\n \nDeliver() =\tif (msg_id == 1){//station 1 sending message to bus\n\t\t\t\t\tDeliver1()\n\t\t\t}else{\n\t\t\t\tif (msg_id == 2){//station 2 sending message to bus\n\t\t\t\t\tDeliver2()\n\t\t\t\t}else{//station 3 sending message to bus\n\t\t\t\t\tDeliver3()\n\t\t\t\t}\n\t\t\t};\n \n//bus broadcasting msg recieved from station 1\nDeliver1() =\tif ( (R.Contains(1) == true && R.Contains(2) == true) || (R.Contains(1) == true && R.Contains(3) == true) ){\n\t\t\t\t\t//relays 1 & 2 are closed, or, relays 1 and 3 are closed\n\t\t\t\t\t//bus recieves msg from station 1, and broadcasts the msg to station 2 & 3\n\t\t\t\t\t\tbtos.2 -> done_btos.2 -> btos.3 -> done_btos.3 -> Skip\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif (R.Contains(2) == true && R.Contains(3) == true){\n\t\t\t\t\t\t//relays 2 & 3 are closed\n\t\t\t\t\t\t//bus recieves msg from station 1, and broadcasts the msg to station 2 & 3\n\t\t\t\t\t\t\tbtos.3 -> done_btos.3 -> btos.2 -> done_btos.2 -> Skip\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif ( R.Contains(1) == true ){\n\t\t\t\t\t\t\t\tbtos.2 -> done_btos.2 -> Skip\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif (R.Contains(3) == true){\n\t\t\t\t\t\t\t\t\tbtos.3 -> done_btos.3 -> Skip\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tSkip\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n \n//bus broadcasting msg recieved from station 2\t\nDeliver2() =\tif ( (R.Contains(1) == true && R.Contains(2) == true) || (R.Contains(2) == true && R.Contains(3) == true) ){\n\t\t\t\t\tbtos.3 -> done_btos.3 -> btos.1 -> done_btos.1 -> Skip\n\t\t\t\t}else{\n\t\t\t\t\tif (R.Contains(1) == true && R.Contains(3) == true){\n\t\t\t\t\t\tbtos.1 -> done_btos.1 -> btos.3 -> done_btos.3 -> Skip\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif ( R.Contains(1) == true ){\n\t\t\t\t\t\t\tbtos.1 -> done_btos.1 -> Skip\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif (R.Contains(2) == true){\n\t\t\t\t\t\t\t\tbtos.3 -> done_btos.3 -> Skip\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tSkip\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n \n//bus broadcasting msg recieved from station 3\nDeliver3() =\tif ( (R.Contains(1) == true && R.Contains(3) == true) || (R.Contains(2) == true && R.Contains(3) == true) ){\n\t\t\t\t\tbtos.1 -> done_btos.1 -> btos.2 -> done_btos.2 -> Skip \n\t\t\t\t}else{\n\t\t\t\t\tif (R.Contains(1) == true && R.Contains(2) == true){\n\t\t\t\t\t\tbtos.2 -> done_btos.2 -> btos.1 -> done_btos.1 -> Skip\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif ( R.Contains(2) == true ){\n\t\t\t\t\t\t\tbtos.2 -> done_btos.2 -> Skip\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif (R.Contains(3) == true){\n\t\t\t\t\t\t\t\tbtos.1 -> done_btos.1 -> Skip\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tSkip\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n \n/*---------------------Lift process--------------------------------------*/\nLift(i) =  [is_setref_pressed == 0]Setref(i) \n\t\t[] [is_setref_pressed == 1]Wait_init_phase(i);\n \n/* Lift i has its SETREF button pressed */\nSetref(i) = setref.i{is_setref_pressed = 1; pressed_SETREF[i] = 1; pos[i] = 1;} -> _STARTUP{state[i] = STARTUP;} \n\t\t\t\t-> req -> set_relay_close{relay_closed = i;} -> close_relay -> rel \n\t\t\t\t-> req -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = STARTUP;} -> stob_init \n\t\t\t\t-> set_relay_open{relay_opened = i;} -> open_relay -> rel\n\t\t\t\t-> Wait_For_STARTUP(i); set_num.i{num[i] = pos[msg_id];} -> _STANDBY{state[i] = STANDBY;} -> done_btos.i /*wait for a startup msg*/\n\t\t\t\t-> req -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = state[i];} -> stob -> rel -> NORMAL_OPR(i);\n \nWait_For_STARTUP(i) = btos.i -> ( [msg_state == STARTUP] (Skip) [] [msg_state != STARTUP] (done_btos.i -> Wait_For_STARTUP(i)));\n \n/* Lift i wait for a STARTUP msg to start */\nWait_init_phase(i) = Wait_For_STARTUP(i); set_pos.i{pos[i] = msg_pos + 1; num[i] = pos[i];} \n\t\t\t\t -> _STARTUP{state[i] = STARTUP;} -> done_btos.i\n\t\t\t\t -> req -> set_relay_close{relay_closed = i;} -> close_relay -> rel \n\t\t\t\t -> req -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = STARTUP;} -> stob -> rel -> Wait_For_STANDBY(i);\n \n/*---------------------Wait_For_STANDBY process--------------------------------------*/\n/* After received a STARTUP msg, Lift i continues to receive STARTUP/STANDBY msg, and will go to STANDBY state while recieving a STANDBY msg */\nWait_For_STANDBY(i) = \tbtos.i -> ([msg_state == STARTUP]set_num.i{num[i] = pos[msg_id];} -> done_btos.i -> Wait_For_STANDBY(i) \n\t\t\t\t\t [] [msg_state == STANDBY]_STANDBY{state[i] = msg_state;} -> done_btos.i -> NORMAL_OPR(i)\n\t\t\t\t\t [] [msg_state != STARTUP && msg_state != STANDBY]done_btos.i -> Wait_For_STANDBY(i));\n \n/*---------------------NORMAL_OPR process--------------------------------------*/\n/* At STANDBY state, Lift i can initiate an operation or wait for SYNC msg for a operation */\nNORMAL_OPR(i) =  ( [has_active_station == 0] Active(i) )\n\t\t\t   [] ( [has_active_station == 1]Passive(i) );\n \nActive(i) =  req -> startActive.i->\t(\n\t\t\t\t\t\t( \t\tup.i{has_active_station = 1; active[i] = 1;} -> _UP{state[i] = UP;} -> rel \n\t\t\t\t\t\t\t\t->  req -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = state[i];} -> stob -> rel\n\t\t\t\t\t\t\t\t-> \tActive_con(i)\n\t\t\t\t\t\t)\n\t\t\t\t\t[]\n\t\t\t\t\t\t( \t\t\tdown.i{has_active_station = 1; active[i] = 1;} -> _DOWN{state[i] = DOWN;} -> rel\n\t\t\t\t\t\t\t\t->  req -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = state[i];} -> stob -> rel\n\t\t\t\t\t\t\t\t->  Active_con(i)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\nPassive(i) =       btos.i \n\t\t\t\t\t-> if (msg_state == SYNC){\n\t\t\t\t\t    \t_SYNC{state[i] = msg_state;} -> move.i -> done_btos.i -> Passive(i)\n\t\t\t\t\t   }else{\n\t\t\t\t\t    \tif (msg_state == STANDBY){\n\t\t\t\t\t    \t\t_STANDBY{state[i] = msg_state;} -> done_btos.i -> NORMAL_OPR(i)\n\t\t\t\t\t    \t}else{\n\t\t\t\t\t    \t\tif ( i == suc[msg_id]){\n\t\t\t\t\t    \t\t\tadopt_state{state[i] = msg_state;} -> done_btos.i\n\t\t\t\t\t    \t\t-> req -> set_message{msg_id = i; msg_pos = suc[msg_pos]; msg_state = state[i];} -> stob -> rel -> Passive(i)\n\t\t\t\t\t    \t\t}else {\n\t\t\t\t\t    \t\t\tadopt_state{state[i] = msg_state;} -> done_btos.i -> Passive(i)\n\t\t\t\t\t    \t\t}\n\t\t\t\t\t    \t}\n\t\t\t\t\t   };\n \n/*---------------------Active_con process--------------------------------------*/\n/* After activating an operation, Lift i either releases the press button, or continues the operation by receiving msg or sending SYN */\n Active_con(i) =\tif (state[1] == STANDBY && state[2] == STANDBY && state[3] == STANDBY){\n \t\t\t\t\tRelease(i)\n \t\t\t\t}else{\n \t\t\t\t\tReceive_or_Sync(i)\n \t\t\t\t};\n \n Release(i) = req -> release.i{has_active_station = 0; active[i] = 0;} -> rel -> NORMAL_OPR(i);\n \n Receive_or_Sync(i) = \t\tbtos.i\n \t\t\t\t\t\t->  if (msg_state == state[i]){\n \t\t\t\t\t\t\tif ( i == suc[msg_id]){\n \t\t\t\t\t\t\t\tdone_btos.i\n\t\t\t\t\t\t\t\t->\treq -> _SYNC{state[i] = SYNC;} -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = state[i];} -> stob -> move.i-> rel\n\t\t\t\t\t\t\t\t->  req -> _STANDBY{state[i] = STANDBY;} -> set_message{msg_id = i; msg_pos = pos[i]; msg_state = STANDBY;} -> stob -> rel\n\t\t\t\t\t\t\t\t->  Active_con(i)\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tdone_btos.i -> Receive_or_Sync(i)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tSkip\n\t\t\t\t\t\t};\n \n/*----------------------------System Process--------------------------------------------*/\nSystem () = Bus() || ( Lift(1) ||| Lift(2) ||| Lift(3) );\n \n///////////////////VERIFICATION///////////////////\n \n// Property 1: DeadLock freeness Checking\n#assert System() deadlockfree;\n \n// Property 2: all lifts will eventually always knows that the number of stations in the network is 3\n#define NUMSET num[1] == 3 && num[2] == 3 && num[3] == 3;\n#assert System |= <>[] NUMSET;\n \n// Property 3: all lifts will eventually always obtains a correct position\n#define POSSET (pos[1] !=  pos[2] && pos[1] !=  pos[3] && pos[3] !=  pos[2] \n\t\t\t\t\t && pos[1] >= 1 && pos[1] <= 3 \n\t\t\t\t\t && pos[2] >= 1 && pos[2] <= 3 \n\t\t\t\t\t && pos[3] >= 1 && pos[3] <= 3 );\n#assert System |= <>[] POSSET;\n \n// Property 4: each station is able to change to active state\n#define Active1 active[1] == 1;\n#define Active2 active[2] == 1;\n#define Active3 active[3] == 1;\n#assert System() reaches Active1;\n#assert System() reaches Active2;\n#assert System() reaches Active3;\n \n// Property 5: at most 1 station is allowed to initiate an operation at a time\n#define MultiActive active[1] + active[2] + active[3] > 1;\n#assert System |= [] (!MultiActive);\n \n// Property 6: relays can not be all closed at the same time\n#define AllRelaysAreClose (R.Count() == ST);\n#assert System() |= [](!AllRelaysAreClose);\n \n// Property 7: all lifts will move in the same direction\n#define AllMoveUP state[1] == UP && state[2] == UP && state[3] == UP;\n#define AllMoveDown state[1] == DOWN && state[2] == DOWN && state[3] == DOWN;\n#assert System() |= [] (up.1 -> <> AllMoveUP);\n#assert System() |= [] (down.1 -> <> AllMoveDown);\n \n// Property 8: one lift can never move in a different direction from other lifts\n#define MoveUpOrDownDifferent \t ((state[1] == \t UP && state[2] == \t UP && state[3] == DOWN)\n\t\t\t\t\t\t||(state[1] == DOWN && state[2] == DOWN && state[3] == UP)\n\t\t\t\t\t\t||(state[2] == \t UP && state[3] == \t UP && state[1] == DOWN)\n\t\t\t\t\t\t||(state[2] == DOWN && state[3] == DOWN && state[1] == UP)\n\t\t\t\t\t\t||(state[1] == \t UP && state[3] == \t UP && state[2] == DOWN)\n\t\t\t\t\t\t||(state[1] == DOWN && state[3] == DOWN && state[2] == UP)\n\t\t\t\t\t\t);\n#assert System() |= [] (!MoveUpOrDownDifferent);\n \n// Property 9: at most one lift can press the SETREF button at a time\n#define MultiSETREF pressed_SETREF[1] + pressed_SETREF[2] + pressed_SETREF[3] > 1;\n#assert System() |= [](!MultiSETREF);\n \n// Property 10: only when there is an active lift can any lift moves up/down\n#define MoveUP state[1] == UP || state[2] == UP || state[3] == UP;\n#define MoveDOWN state[1] == DOWN || state[2] == DOWN || state[3] == DOWN;\n#define ACTIVATED has_active_station == 1;\n#assert System() |= [](MoveUP -> ACTIVATED); // Alternatively, #assert System() |= []((!MoveUP) U ACTIVATED);\n \n// Property 11: lifts can start active infinitely often\n#assert System() |= [](<>(startActive.1 || startActive.2 || startActive.3));\n \n/////Refinement Checking/////\nSystem_ACTIVE() = \tSystem() \\ {req, rel, \n\t\t\t\t\t\t\tstob,stob_init,\n\t\t\t\t\t\t\t_STARTUP,_STANDBY,_SYNC,_UP,_DOWN,\n\t\t\t\t\t\t\tset_pos.1,set_pos.2,set_pos.3,\n\t\t\t\t\t\t\tset_num.1,set_num.2,set_num.3,\n\t\t\t\t\t\t\topen_relay,close_relay,\n\t\t\t\t\t\t\tupdate_r_list,\n\t\t\t\t\t\t\tbtos.1, btos.2, btos.3,\n\t\t\t\t\t\t\tdone_btos.1, done_btos.2, done_btos.3,\n\t\t\t\t\t\t\tsetref.1, setref.2, setref.3,\n\t\t\t\t\t\t\tset_relay_close, set_relay_open,\n\t\t\t\t\t\t\tset_message,\n\t\t\t\t\t\t\tset_stable,\n\t\t\t\t\t\t\tendCheckProblem1,\n\t\t\t\t\t\t\tadopt_state,\n\t\t\t\t\t\t\tstable,\n\t\t\t\t\t\t\tup.1, up.2, up.3,\n\t\t\t\t\t\t\tdown.1, down.2, down.3,\n\t\t\t\t\t\t\tmove.1, move.2, move.3\t\t\t\t\t\t\n\t\t\t\t\t};\n\n\n// Property 12: check if one station got active first, the system also allows other stations to activate later\nACTIVE_ORDERED() = \t(startActive.1 -> release.1 -> startActive.2 -> release.2 -> startActive.3 -> release.3 -> ACTIVE_ORDERED())\n\t\t\t\t\t\t[]\n\t\t\t\t\t\t(startActive.1 -> release.1 -> startActive.3 -> release.3 -> startActive.2 -> release.2 -> ACTIVE_ORDERED())\n\t\t\t\t\t\t[]\n\t\t\t\t\t\t(startActive.2 -> release.2 -> startActive.1 -> release.1 -> startActive.3 -> release.3 -> ACTIVE_ORDERED())\n\t\t\t\t\t\t[]\n\t\t\t\t\t\t(startActive.2 -> release.2 -> startActive.3 -> release.3 -> startActive.1 -> release.1 -> ACTIVE_ORDERED())\n\t\t\t\t\t\t[]\n\t\t\t\t\t\t(startActive.3 -> release.3 -> startActive.1 -> release.1 -> startActive.2 -> release.2 -> ACTIVE_ORDERED())\n\t\t\t\t\t\t[]\n\t\t\t\t\t\t(startActive.3 -> release.3 -> startActive.2 -> release.2 -> startActive.1 -> release.1 -> ACTIVE_ORDERED())\n\t\t\t\t\t\t;\n#assert ACTIVE_ORDERED()  refines System_ACTIVE();\n\n// Property 13: check whether system allows one station gets active continuously\nACTIVE_RANDOMLY() = \t(startActive.1 -> release.1 -> ACTIVE_RANDOMLY())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.2 -> release.2 -> ACTIVE_RANDOMLY())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.3 -> release.3 -> ACTIVE_RANDOMLY())\n\t\t\t\t\t;                \n#assert ACTIVE_RANDOMLY()  refines System_ACTIVE();\n\n\nSystem_MOVE() = \tSystem() \\ {req, rel, \n\t\t\t\t\t\t\tstob,stob_init,\n\t\t\t\t\t\t\t_STARTUP,_STANDBY,_SYNC,_UP,_DOWN,\n\t\t\t\t\t\t\tset_pos.1,set_pos.2,set_pos.3,\n\t\t\t\t\t\t\tset_num.1,set_num.2,set_num.3,\n\t\t\t\t\t\t\topen_relay,close_relay,\n\t\t\t\t\t\t\tbtos.1, btos.2, btos.3,\n\t\t\t\t\t\t\tdone_btos.1, done_btos.2, done_btos.3,\n\t\t\t\t\t\t\tsetref.1, setref.2, setref.3,\n\t\t\t\t\t\t\tset_relay_close, set_relay_open,\n\t\t\t\t\t\t\tset_message,set_stable,\n\t\t\t\t\t\t\tendCheckProblem1,\n\t\t\t\t\t\t\tadopt_state,stable,\n\t\t\t\t\t\t\tup.1, up.2, up.3,\n\t\t\t\t\t\t\tdown.1, down.2, down.3,update_r_list\t\t\t\t\t\t\n\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\n// Property 14: check whether system allows every lift can move after one station gets active state\nMOVE_After_ACTIVE() = \t(startActive.1 -> move.1 -> move.2 -> move.3 -> release.1 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.1 -> move.1 -> move.3 -> move.2 -> release.1 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.1 -> move.2 -> move.1 -> move.3 -> release.1 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.1 -> move.2 -> move.3 -> move.1 -> release.1 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.1 -> move.3 -> move.1 -> move.2 -> release.1 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.1 -> move.3 -> move.2 -> move.1 -> release.1 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.2 -> move.1 -> move.2 -> move.3 -> release.2 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.2 -> move.1 -> move.3 -> move.2 -> release.2 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.2 -> move.2 -> move.1 -> move.3 -> release.2 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.2 -> move.2 -> move.3 -> move.1 -> release.2 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.2 -> move.3 -> move.1 -> move.2 -> release.2 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.2 -> move.3 -> move.2 -> move.1 -> release.2 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.3 -> move.1 -> move.2 -> move.3 -> release.3 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.3 -> move.1 -> move.3 -> move.2 -> release.3 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.3 -> move.2 -> move.1 -> move.3 -> release.3 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.3 -> move.2 -> move.3 -> move.1 -> release.3 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.3 -> move.3 -> move.1 -> move.2 -> release.3 -> MOVE_After_ACTIVE())\n\t\t\t\t\t[]\n\t\t\t\t\t(startActive.3 -> move.3 -> move.2 -> move.1 -> release.3 -> MOVE_After_ACTIVE());\n#assert System_MOVE()  refines MOVE_After_ACTIVE();"
  },
  {
    "id": "driving_philo",
    "name": "The Driving Philosophers",
    "matchtype": "loose match",
    "description": "This system models the Driving Philosophers Problem, a synchronization challenge arising in mobile ad-hoc networks. In this problem, an unbounded number of 'philosopher' processes aim to sequentially occupy a series of shared resources arranged around a logical ring, representing a roundabout. Each philosopher must acquire all the resources in their required segment before proceeding to drive, and only after completing the drive can they release the resources. Entry and exit are treated as distinct phases, emphasizing resource reservation before action. The model captures resource contention, progress, fairness, and mutual exclusion, demonstrating the complexities of distributed coordination when multiple entities interact over overlapping critical sections without central control.",
    "variable": "num_philosophers (at least 2) and num_resources (at least 1)",
    "implementation": "/***************************************************************************************************\nThe Driving Philosophers is a new synchronization problem in mobile ad-hoc systems. \nIn this problem, an unbounded number of driving philosophers (processes) try to access \na round-about (set of shared resources, organized along a logical ring).   \nThe process does not release the resources it has occupied until it occupies all the resources it needs.\n\"enter\" and \"exit\" are separated as two phases.\n*****************************************************************************************************/\n\n//the number of philosophers\n#define N 2; \n//the number of resources\n#define M 4; \n\n//the start and end resource of each philosopher\n#define ph1_start 0;\n#define ph1_end   3;\n\n#define ph2_start 1;\n#define ph2_end   2;\n\n//for each i:\n//start_end[i*2] indicates the i-th philosopher's start resource\n//start_end[i*2+1] indicates the i-th philosopher's end resource \nvar start_end[2*N] = [ph1_start,ph1_end,ph2_start,ph2_end];\n\n//pointer[i] indicates the current resource which i-th philosopher needs to enter\nvar pointer[N]:{0..M-1} = [ph1_start,ph2_start];\n\n//-----------------paste the testing data in \"data.text\" above for convenience-------------------- \n\n//flag[i*2]==1: the i-th philosopher has done the drive and can exit the resources\n//flag[i*2+1]==1: the i-th phiolsopher has entered all the resources it needs and can drive\nvar flag[2*N]:{0..1};\n \n//variables for the fairness\nvar count[N];\nvar sum;\n\n//resource[k] indicates the current number of phil which enters k-th resource\n//this variable is only for testing the mutex. it will NOT appear in any preconditions\nvar resource[M];\n\n//this variable is only for testing if there is a state that two processes share one resource\nvar mutex = false;\n\n/***************************************************************************************************\nThe second part is the modeling of the philosopher.\nAssume: 1.Each philosopher needs to enter a finite continuous sequence of resources to drive.\n        2.Each philosopher enters the resources which it needs by sequence until its end resource \n          is entered and starts at its start resource.\n        3.Each philosopher exits the resources after its driving by sequence and\n          starts at its first entered resource.\n*****************************************************************************************************/\n\n//Mainly, in this case, every phil has three phases: occupy all the resources->drive->release all the resources\n//Simply, here can use \"if else\" to control the process, but we use \"[]\" to split the process to 3 subprocesses just for clarity\n\nPhilosopher(i)=[count[i]*N <= sum]   // \"counter\" method is used to ensure the fairness        \n               Phil_occupy(i) [] Phil_drive(i) [] Phil_release(i);\n           \nPhil_occupy(i) =[]k:{0..M-1}@Phil_enter(i,k);\nPhil_release(i)=[]k:{0..M-1}@Phil_exit(i,k);\n\n//i-th philosopher enters the k-th resource\nPhil_enter(i,k) = [flag[i*2+1]==0 && flag[i*2]==0 && k==pointer[i]]\n                  enter.i.k\n                  -> {                                   //tau event is to update      \n                         resource[k]++;\n               \t\t     if(k==start_end[i*2+1])\n               \t\t     flag[i*2+1]=1;\n               \t\t     pointer[i] = (pointer[i]+1)%M;\n                     }\n                  -> occupied.i.k\n                  -> Philosopher(i);\n        \n//i-th philosopher drives              \nPhil_drive(i) = [flag[i*2]==0 && flag[i*2+1]==1]\n                drive.i\n                {\n                    flag[i*2] = 1;\n                 \tsum = sum +1;\n                 \tcount[i] = count[i] + 1; \n                 \tif (sum == N){                        //clear the counter variables after all phils have done once driving \n                 \t    sum = 0;                          //otherwise, it will reaches a run time error\n                 \t    var y;                            //and also, it can speed up the verification\n                 \t    while(y<N){\n                 \t    count[y]=0;\n                 \t    y=y+1;}}\n                }\n                -> Philosopher(i);\n               \n//i-th philosopher exits k-th resource              \nPhil_exit(i,k) = [flag[i*2]==1 && k==(start_end[i*2]+start_end[i*2+1]-pointer[i]+1)%M]\n                 exit.i.k\n                 -> {\n                        resource[k]--;\n                        pointer[i]=(pointer[i]-1)%M;\n                        if(pointer[i]==start_end[i*2])\n        \t              {flag[i*2] = 0;\n                           flag[i*2+1]=0;}\n                    }\n                 -> released.i.k\n                 -> Philosopher(i);\n               \n/***************************************************************************************************\nThe third part is the modeling of the resources.\n*****************************************************************************************************/\n\nRes_Phil(i,k) = enter.i.k -> occupied.i.k -> exit.i.k -> released.i.k -> Resource(k);\nResource(k) = []x:{0..N-1}@Res_Phil(x,k);\n\n/***************************************************************************************************\nThe fourth part is the modeling of the system.\n*****************************************************************************************************/\n\nRes()  = ||k:{0..M-1}@Resource(k);\nPhil() = ||x:{0..N-1}@Philosopher(x);\n\nCollege() = Res()||Phil();\n\nTest_mutex = []k:{0..M-1}@([resource[k]>1]{mutex=true}->Test_mutex);\nImplementation = College() || Test_mutex;\n\n\n/***************************************************************************************************\nThe fifth part is the analysis of the system.\n*****************************************************************************************************/\n\n//DEADLOCK CHECKING.\n#assert College() deadlockfree;\n\n//FAIRNESS CHECKING. \n//the aasertion will hold if the system is deadlock free\n#assert College() |= []<> drive.0;\n#assert College() |= []<> enter.0.0;\n\n//MUTEX CHECKING. \n#define Mutex (mutex==true);\n#assert Implementation() reaches Mutex;\n//another way to check mutex (whether resource0 reaches mutex)\n#define Mutex_resource0 (resource[0]>1);\n#assert College() reaches Mutex_resource0;\n//INVALID STATE TRANSITIONS CHECKING.\n//this is for testing whether our model in PAT is consistent to our modeling in DFA (Details are discussed in report)\n#define BadTransition (flag[1] == 0 && flag[0] == 1); //phil0 has done driving but not entered all resources\n#assert College reaches BadTransition;\n"
  },
  {
    "id": "ssl",
    "name": "Secure Sockets Layer (SSL) Protocol",
    "matchtype": "loose match",
    "description": "This model implements a simplified Secure Sockets Layer (SSL)/TLS handshake protocol, capturing the full negotiation and re-negotiation process between a client and a server, while explicitly modeling a potential active man-in-the-middle attacker. The concrete interactions include message exchanges like Hello, Certificate, KeyExchange, ChangeCipherSpec, and Finished, with each side updating connection state upon completion. The attacker can relay, intercept, or impersonate either party, and a specific attack scenario is encoded to demonstrate a known vulnerability: the attacker successfully mediates the communication, leading both client and server to believe they are securely connected to each other. The model verifies this violation condition and checks for protocol deadlock-freedom.",
    "variable": "",
    "implementation": "enum{ServerHello,ServerCertificate,ServerKeyExchange,ServerCertificateRequest,\n        ServerHelloDone,ServerChangeCipherSpec,ServerFinished,HelloRequest,\n        Certificate,KeyExchange,CertificateVerify,ChangeCipherSpec,Finished,Hello,\n        Nobody, Client, Server, Attacker,\n        client_server_key, attacker_server_key};\n\nchannel network 0;\nchannel attackerBuffer 3;\n\nvar client_connects = Nobody;\nvar server_connects = Nobody;\nvar attacker_server_connected = false;\n\nClientProc() = ClientNegotiate();\nClientNegotiate() = \n   network!Client.Hello ->\n   network?ServerHello ->\n   network?ServerCertificate ->\n   network?ServerKeyExchange ->\n   network?ServerCertificateRequest ->\n   network?ServerHelloDone ->\n   network!Client.Certificate ->\n   network!Client.KeyExchange ->\n   network!Client.CertificateVerify ->\n   network!Client.ChangeCipherSpec ->\n   network!Client.Finished ->\n   network?ServerChangeCipherSpec ->\n   network?ServerFinished ->\n   clientconnected{client_connects = Server} ->\n   ClientConnected();\n   \nClientConnected() = network?client_server_key.HelloRequest -> ClientReNegotiate();\n\nClientReNegotiate() = \n   network!client_server_key.Client.Hello ->\n   network?client_server_key.ServerHello ->\n   network?client_server_key.ServerCertificate ->\n   network?client_server_key.ServerKeyExchange ->\n   network?client_server_key.ServerCertificateRequest ->\n   network?client_server_key.ServerHelloDone ->\n   network!client_server_key.Client.Certificate ->\n   network!client_server_key.Client.KeyExchange ->\n   network!client_server_key.Client.CertificateVerify ->\n   network!client_server_key.Client.ChangeCipherSpec ->\n   network!client_server_key.Client.Finished ->\n   network?client_server_key.ServerChangeCipherSpec ->\n   network?client_server_key.ServerFinished ->\n   ClientConnected();\n\nServerProc() = ServerNegotiate();\nServerNegotiate() = \n   network?x.Hello ->\n   network!ServerHello ->\n   network!ServerCertificate ->\n   network!ServerKeyExchange ->\n   network!ServerCertificateRequest ->\n   network!ServerHelloDone ->\n   network?x.Certificate ->\n   network?x.KeyExchange ->\n   network?x.CertificateVerify ->\n   network?x.ChangeCipherSpec ->\n   network?x.Finished ->\n   network!ServerChangeCipherSpec ->\n   network!ServerFinished ->\n   serverconnected{server_connects = x} ->\n   ServerConnected(x);\n\nServerConnected(x) =\n   if (x == Client) {\n       network!client_server_key.HelloRequest -> ServerReNegotiate(client_server_key)\n   }\n   else {\n       network!attacker_server_key.HelloRequest -> ServerReNegotiate(attacker_server_key)\n   };\n\nServerReNegotiate(x) = \n   network?x.y.Hello ->\n   network!x.ServerHello ->\n   network!x.ServerCertificate ->\n   network!x.ServerKeyExchange ->\n   network!x.ServerCertificateRequest ->\n   network!x.ServerHelloDone ->\n   network?x.y.Certificate ->\n   network?x.y.KeyExchange ->\n   network?x.y.CertificateVerify ->\n   network?x.y.ChangeCipherSpec ->\n   network?x.y.Finished ->\n   network!x.ServerChangeCipherSpec ->\n   network!x.ServerFinished ->\n   serverconnected{server_connects = y} ->\n   ServerConnected(y);\n\n aSystem = ClientProc() ||| ServerProc();\n bSystem = AttackerProc() ||| ServerProc();\n\nAttackerProc() = AttackerNegotiate() [] AttackerAsServer() [] AttackerRelay() [] AttackerReNegotiate();\n\nAttackerRelay() = attackerBuffer?x.y -> network!attacker_server_key.x.y -> AttackerProc()\n               [] network?y.z -> attackerBuffer!y.z -> AttackerProc() \n               [] network?attacker_server_key.y -> network!y -> AttackerProc() \n               [] network?y.z -> network!attacker_server_key.y.z -> AttackerProc();\n\nAttackerAsServer() = network?Client.Hello -> attackerBuffer!Client.Hello -> AttackerProc();\n\nAttackerNegotiate() = \n   network!Attacker.Hello ->\n   network?ServerHello ->\n   network?ServerCertificate ->\n   network?ServerKeyExchange ->\n   network?ServerCertificateRequest ->\n   network?ServerHelloDone ->\n   network!Attacker.Certificate ->\n   network!Attacker.KeyExchange ->\n   network!Attacker.CertificateVerify ->\n   network!Attacker.ChangeCipherSpec ->\n   network!Attacker.Finished ->\n   network?ServerChangeCipherSpec ->\n   network?ServerFinished ->\n   attackerconnected{attacker_server_connected = true} ->\n   AttackerConnected();\n\nAttackerConnected() = network?attacker_server_key.HelloRequest -> AttackerProc();\n\nAttackerReNegotiate() = \n   network!attacker_server_key.Attacker.Hello ->\n   network?attacker_server_key.ServerHello ->\n   network?attacker_server_key.ServerCertificate ->\n   network?attacker_server_key.ServerKeyExchange ->\n   network?attacker_server_key.ServerCertificateRequest ->\n   network?attacker_server_key.ServerHelloDone ->\n   network!attacker_server_key.Attacker.Certificate ->\n   network!attacker_server_key.Attacker.KeyExchange ->\n   network!attacker_server_key.Attacker.CertificateVerify ->\n   network!attacker_server_key.Attacker.ChangeCipherSpec ->\n   network!attacker_server_key.Attacker.Finished ->\n   network?attacker_server_key.ServerChangeCipherSpec ->\n   network?attacker_server_key.ServerFinished ->\n   AttackerConnected();\n\nSpecificAttacker = \n   network?Client.Hello -> attackerBuffer!Client.Hello ->\n   network!Attacker.Hello ->\n   network?ServerHello ->\n   network?ServerCertificate ->\n   network?ServerKeyExchange ->\n   network?ServerCertificateRequest ->\n   network?ServerHelloDone ->\n   network!Attacker.Certificate ->\n   network!Attacker.KeyExchange ->\n   network!Attacker.CertificateVerify ->\n   network!Attacker.ChangeCipherSpec ->\n   network!Attacker.Finished ->\n   network?ServerChangeCipherSpec ->\n   network?ServerFinished ->\n   attackerconnected{attacker_server_connected = true} ->\n   network?attacker_server_key.HelloRequest ->\n   attackerBuffer?Client.Hello ->\n   network!attacker_server_key.Client.Hello -> \n   SpecificRelay();\n\nSpecificRelay() = network?attacker_server_key.y -> network!y -> SpecificRelay()\n               [] network?x.z -> network!attacker_server_key.x.z -> SpecificRelay();\n\nTLS = ServerProc() ||| AttackerProc() ||| ClientProc();\nTLSWithSpecificAttacker = ServerProc() ||| SpecificAttacker() ||| ClientProc();\n\n#define violation ((attacker_server_connected) && (server_connects == Client) && (client_connects == Server));\n#assert TLS deadlockfree;\n#assert TLS reaches violation;\n#assert TLSWithSpecificAttacker reaches violation;"
  },
  {
    "id": "kvalued",
    "name": "K-valued Register System: Infinite Readers",
    "matchtype": "loose match",
    "description": "This model implements a K-valued Register System using a unary-encoded binary array to support multi-valued writes and an unbounded number of concurrent readers. The register value is encoded by setting a single 1 at the target index and clearing all lower bits. Readers perform a two-phase traversal (up-scan and down-scan) to locate the most recently written value without coordination or interference. This design enables scalable and passive read operations, relying solely on shared memory inspection. The system is verified for deadlock-freedom and ensures that every read eventually returns a valid value.",
    "variable": "num_register_values (at least 3) and num_readers (at least 1)",
    "implementation": "//shared binary array of size N\nvar B = [0,0,1];\n\n////////////////The Concrete Implementation Model//////////////////\nReaders() = read_inv -> UpScan(0);\nUpScan(i) =  if(B[i] == 1) { DownScan(i - 1, i) } else { UpScan(i + 1) };\nDownScan(i, v) =\n\t\tifa(i >= 0) {\n\t\t\tif(B[i] == 1) { DownScan(i - 1, i) } else { DownScan(i - 1, v) }\n\t\t} else {\n\t\t\tt -> read_res.v -> Readers()\n\t\t};\n\nWriter(i) = write_inv.i -> t{B[i] = 1;} -> WriterDownScan(i-1);\nWriterDownScan(i) = if(i >= 0 ) { t{B[i] = 0;} -> WriterDownScan(i-1) } else { write_res -> Skip } ;\n\nWriters() = (Writer(0)[]Writer(1)[]Writer(2)); Writers();\nRegister() = ((|||{2}@Readers()) ||| Writers());\n\n////////////////The Properties//////////////////\n#assert Register() deadlockfree;\n#assert Register() |= []<> read_res.2;\n#assert Register() |= [](read_inv -> <>(read_res.0 ||read_res.1 ||read_res.2));"
  },
  {
    "id": "para_stack",
    "name": "Parameterized Concurrent Stack System",
    "matchtype": "loose match",
    "description": "This system models a Parameterized Concurrent Stack System, demonstrating how a shared stack can be manipulated by an infinite number of processes operating concurrently.",
    "variable": "stack_size (at least 3) and num_processes (at least 1)",
    "implementation": "//stack size\n#define SIZE 3;\n\n//shared head pointer for the concrete implementation\nvar H = 0;\n\n////////////////The Concrete Implementation Model//////////////////\nPush() = push_inv -> PushLoop(H);\n\nPushLoop(v) = (\n\tifa (v == H) {\n\t\tt{if(H < SIZE) {H = H+1;}} -> push_res.(v+1) -> Process()\n\t} else {\n\t\tPush()\n\t});\n\t\nPop() = pop_inv -> \tPopLoop(H);\n\nPopLoop(v) = \n\t(if(v == 0) {\n\t\tpop_res.0 -> Process() \n\t} else {\n\t\t(ifa(v != H) { Pop() } else { t{H = H-1;} -> pop_res.(v-1) -> Process()\n\t\t})\n\t});\n\nProcess() = (Push()[]Pop());\nStack() = (|||{2}@Process());\n\n#assert Stack() deadlockfree;\n#assert Stack() |= [](push_inv -> <>(push_res.0 ||push_res.1 ||push_res.2));\n"
  },
  {
    "id": "java",
    "name": "Mutual Exclusion of Java Meta-Lock",
    "matchtype": "loose match",
    "description": "This model implements the Java Meta-Lock problem, simulating a lock acquisition mechanism where threads attempt fast or slow paths to enter a critical section depending on contention. A shared object transitions between an uncontended (Busy_0) and contended (Busy_N) state based on how many threads are waiting, tracked by a count variable. Threads first attempt a non-blocking fast path; if unsuccessful, they enter a coordinated slow path using a handoff protocol that grants access via request-release-go messaging. The model ensures mutual exclusion and liveness properties and is verified for deadlock-freedom and eventual access to the critical section.",
    "variable": "num_waiting (at least 1) and system_type (either 'finite_threads' or 'infinite_threads')",
    "implementation": "#define N 2; /* max num of threads that can wait at waiting state */\n\n/* msg */\n#define put_fast 100;\n#define get_fast 101;\n#define go 102;\n#define request 103;\n#define release 104;\n#define get_slow 105;\n#define put_slow 106;\n\nchannel ascChan 0;\nvar count =0;\nvar access = false;\n\nhandoff() = ascChan?release -> ascChan?request -> ascChan!go -> handoff()\n         [] ascChan?request -> ascChan?release -> ascChan!go -> handoff();\n\nshared_obj() = ascChan?get_fast -> Busy_0();\n\nBusy_0() = ascChan?put_fast -> shared_obj()\n        [] ascChan?get_slow -> inc{count = count+1;} -> Busy_N();\n\nBusy_N() = [count < N]ascChan?get_slow -> inc{count = count+1;} -> Busy_N()\n        [] ascChan?put_slow -> dec{count = count -1;} ->\n            (\n              if(count == 0){\n                 Busy_0()\n              } else {\n                 Busy_N()\n              }\n           );\n                \n\nmy_thread() = ascChan!get_fast -> enterCritical{access = true;} ->Owner()\n         [] ascChan!get_slow -> ascChan!request -> ascChan?go -> enterCritical{access = true;} ->Owner();\n\nOwner() = leaveCritical{access = false;} ->\n          (\n               ascChan!put_fast -> my_thread()\n            [] ascChan!put_slow -> ascChan!release -> my_thread()\n          );\n\nSystem() = ((|||{..}@my_thread())||| handoff() ||| shared_obj());\n\n#assert System() deadlockfree;\n#define someoneaccess access == true;\n#assert System() |= []<>someoneaccess;"
  },
  {
    "id": "PATlang",
    "name": "PAT Language Features Demonstration",
    "matchtype": "loose match",
    "description": "This model demonstrates various language features of PAT, including support for multi-dimensional arrays, synchronous and asynchronous channels, and structured communication with multiple data elements. It highlights that while arrays can be passed over channels by value, PAT internally treats multi-dimensional arrays as flattened one-dimensional structures during communication. The example also shows the use of constant-based channel pattern matching and emphasizes that received channel data is immutable. The system is structured with two processes exchanging array data and is verified to be deadlock-free.",
    "variable": "",
    "implementation": "#define D1 2;\n#define D2 3;\n\n//A synchronous channel\nchannel c 0;\n\n//An asynchronous channel\nchannel ac 1;\n\n//example of multi-dimensional array \nvar x[D1][D2];\n//example of multi-dimensional array with initial value\nvar y[D1][D2] = [1..6];\n\n//example of channel to send multiple data in one action. An array can be sent in the channel as a whole.\n//in the channel input events, constanst can be used to make sure that only channel data with matching value are received, otherwise the input event is blocked.\nP(i) = c!x.i -> ac?u.1 -> P(x);\n\nQ(i) = c?z.m -> \n\t   //the channel communication are pass-by-value, change the value of x will not affect z.\n\t   //although z is recieved as a two dimensional array, but it can only be accessed as a 1 dimensional array. This is a limiation of PAT, since PAT does not store multi-dimentional array internally.\n\t   tau{x[0][1] = 5; x[0][2] = z[1];} ->\n\t   //value of z can be used, but can not be updated.\n\t   ac!z[1].m -> Q(m);\n\n aSys1 = P(1) ||| Q(2);\n\n#assert aSys1 deadlockfree;"
  },
  {
    "id": "PATchannel",
    "name": "PAT Channel Operators Demonstration",
    "matchtype": "loose match",
    "description": "This model demonstrates the use of channel operators in PAT for querying the internal state of an asynchronous channel. It showcases runtime inspection using built-in functions such as cpeek (peek first element), ccount (number of stored elements), and csize (channel capacity). Based on the channel\u2019s current state (empty, full, or intermediate), the system either sends, receives, or nondeterministically chooses between both actions. The example illustrates conditional control flow based on channel status and confirms that the system remains deadlock-free under dynamic channel usage.",
    "variable": "",
    "implementation": "//define asynchronous channel\nchannel AC 3;\n\n//define variables\nvar Peek;//used to store the first element in the channel\nvar Size;//used to store the channel size\nvar Count;//used to store how many elements are in the channel\n\n//define processes\n\nSystem = case{\n              call(cempty, AC) : ChannelOutput//if the channel is empty, we can just send data to channel\n              call(cfull, AC) : ChannelInput  //if the channel is full, we can just get data from channel\n              default : ChannelOutput[]ChannelInput // otherwise, we could both send or get data.\n             };\n\n                            //here using some varibles to record the channel's information    \nChannelOutput = AC!Count -> read{Peek = call(cpeek, AC); Size = call(csize, AC); Count = call(ccount, AC)} -> System;\n\n                       //note here: cpeek is used only when the channel is not empty.\nChannelInput = AC?i -> read{Count = call(ccount, AC); if(Count != 0){Peek = call(cpeek, AC);}else{Peek = 0} Count = call(ccount, AC)} -> System;\n\n//assertion\n#assert System deadlockfree;"
  },
  {
    "id": "PATCsharp",
    "name": "PAT C# Libraries Demonstration",
    "matchtype": "loose match",
    "description": "This model demonstrates the use of various C#-inspired libraries in PAT, including List, SerializableList, Stack, Queue, and Set, to showcase object-oriented constructs and data structure operations within process definitions. It illustrates dynamic manipulation of collections (e.g., Add, Remove, Concat, Union, Intersect, Peek, Contains), conditional logic based on internal state, and field/property usage. Each structure is exercised independently to highlight its core behavior and API support, serving as a comprehensive feature demonstration for developers modeling complex systems using familiar C# data abstractions. All components are verified to be deadlock-free.",
    "variable": "",
    "implementation": "#import \"PAT.Lib.List\";\n#import \"PAT.Lib.SerializableList\";\n#import \"PAT.Lib.Stack\";\n#import \"PAT.Lib.Queue\";\n#import \"PAT.Lib.Set\";\n\n//test the list library \nvar<List> list; \nvar<List> list2;\n\n\nList() = field{list$Field = 5; list$Property = list$Field + 3;} -> \n           ((add1{list.Add(1);list2.Add(4);list2.Add(5);} -> add2{list.Add(2);} -> add3{list.Add(3)} -> remove{list.Remove(2);} -> Skip)\n           []\n           (add1{list.Add(2);list2.Add(2);list2.Add(2);} -> add2{list.Add(2);} -> add3{list.Add(3)} -> remove{list.Remove(2);} -> Skip)\n           );\n           \n           \n\t\t\tif(!list.Contains(2))\n\t\t\t{\n\t\t\t\tadd22{list.Add(3);} -> concatenate{list= list.Concat(list, list2);} -> List2()\t\t\t\t\n\t\t\t};\n\nList2() = add1{list.Add(1);}  -> remove{list.Remove(1);} ->remove{list.Remove(2);} -> Skip;\n\n//test the SerializableList list library \nvar<SerializableList> list3; \nvar<SerializableList> list4;\n\n\nList3() = field{list3$Field = 5; list3$Property = list3$Field + 3;} -> \n           ((add1{list3.Add(1);list4.Add(4);list4.Add(5);} -> add2{list3.Add(2);} -> add3{list3.Add(3)} -> remove{list3.Remove(2);} -> Skip)\n           []\n           (add1{list3.Add(2);list4.Add(2);list4.Add(2);} -> add2{list3.Add(2);} -> add3{list3.Add(3)} -> remove{list3.Remove(2);} -> Skip)\n           );\n           \n           \n\t\t\tif(!list3.Contains(2))\n\t\t\t{\n\t\t\t\tadd22{list3.Add(3);} -> concatenate{list3= list3.Concat(list3, list4);} -> List4()\t\t\t\t\n\t\t\t};\n\nList4() = add1{list3.Add(1);}  -> remove{list3.Remove(1);} ->remove{list3.Remove(2);} -> Skip;\n\n\n//test the stack library \nvar<Stack> stack1;\n\nStack() =  push1{stack1.Push(1)}-> clear{stack1.Clear()}-> push2{stack1.Push(2)} -> pop1{stack1.Pop()} -> \n\t\t   push3{stack1.Push(3)} -> if (3 == stack1.Peek()){if ( (stack1.Contains(3)== true) ) { Stack()} };\n\nStackException() =push1{stack1.Push(1)} -> pop1{stack1.Pop()}-> peek{stack1.Peek()} -> StackException();\n\n//test the queue library \nvar<Queue> queue;\nvar<Queue> queue2;\n\nQueue() = enter1{queue.Enqueue(1);queue2.Enqueue(2);queue2.Enqueue(3) } -> enter1{queue.Enqueue(2)} ->\n\t\t  if (1 == queue.First() && 2 == queue.Last())\n\t\t  {\n\t\t  \texit{queue.Dequeue()} -> concat{queue = queue.Concat(queue, queue2)}\n           \t-> if (queue.Contains(3)&& 3 == queue.Count()) {Queue() }\n\t      };\n\n//test the set library\nvar<Set> set1;\nvar<Set> set2;\nvar<Set> set3;\n\nSet() = initialize{ set1.Add(1);set2.Add(2);set3.Add(3);set3.Add(4)} -> remove3 {set3.Remove(4)} ->\n\t\tif (set1.IsDisjoint(set2)== true)\n\t\t{\n\t\t\tunion12{set3 = set3.Union(set1, set2)} ->\n\t\t\t\n\t\t\tif (set1.IsOverlapping(set3)== true)\n\t\t\t{\n\t\t\t\tsubstract3{set3 = set3.Substract(set3,set1)} -> add3{set3.Add(6)} ->\n\t\t\t\t if (set3.Contains(2) == true){intersect23{set3 = set3.Intersect(set3, set2)}-> remove3{set3.Remove(2)} -> Skip}\n\t\t\t}\n\t\t};\n\n#assert List() deadlockfree;\n#assert List3() deadlockfree;\n#assert Stack() deadlockfree;\n#assert Queue() deadlockfree;\n#assert Set() deadlockfree;"
  },
  {
    "id": "PATClib",
    "name": "PAT C Library Demonstration",
    "matchtype": "loose match",
    "description": "This model demonstrates integration with a C-style library function using PAT\u2019s call interface. It showcases how external C functions, such as plus, can be invoked within a process, with their return values assigned to local variables (x). The system performs a computation (1 + 2), stores the result, and outputs it, illustrating seamless use of external logic within the PAT modeling environment. The example is simple yet effective in demonstrating foreign function calls and is verified to be deadlock-free.",
    "variable": "",
    "implementation": "#import \"PAT.Lib.CMethodDemo\";\n\nvar x;\n\nSystem = event{x = call(plus, 1,2);} -> out.x -> Skip;\n#assert System() deadlockfree;"
  },
  {
    "id": "1dchannel",
    "name": "PAT 1d Channel Array Demonstration",
    "matchtype": "loose match",
    "description": "This model demonstrates the use of a 1-dimensional channel array in PAT to construct a pipeline system. Each element in the right channel array represents a synchronous communication link between adjacent stages. The Send process injects data at the start of the pipeline, while Receive consumes it at the end. Intermediate COPY processes forward values from right[i] to right[i+1], effectively modeling a data propagation chain. The setup exemplifies how indexed channels enable modular and scalable design patterns. The system is verified to be deadlock-free.",
    "variable": "num_pipes (at least 2)",
    "implementation": "#define N 3;\n\n//a synchronous channel array\nchannel right[N+1] 0;  \n\n//example of channel array to send data in one action\nSend() = right[0]!5 -> Send();\n//example of channel array to receive data in one action\nReceive() = right[N]?x -> Receive();\n\nCOPY(i) = right[i]?x -> right[i+1]!x -> COPY(i);\nPIPE() = ||| i:{0..(N-1)} @ COPY(i);\n\nSystem() = PIPE() ||| Send() ||| Receive();\n\n#assert System() deadlockfree;"
  },
  {
    "id": "2dchannel",
    "name": "PAT 2d Channel Array Demonstration",
    "matchtype": "loose match",
    "description": "This model demonstrates a 2-dimensional channel array simulation in PAT using flattened 1D channel arrays to represent a grid-based communication network. Each cell at position (i, j) can send messages to its right and downward neighbors via indexed channels right[i*N + j] and down[i*N + j]. The Send, Receive, and Cell processes model message propagation across rows and columns, simulating data flow in a mesh-like topology. This example showcases how multidimensional channel communication can be encoded using linear indexing, enabling scalable and structured system designs. The system is verified to be deadlock-free.",
    "variable": "num_rows (at least 2) and num_cols (at least 2)",
    "implementation": "#define M 2; // raw number \n#define N 3; // column number\n\n// The following are one-dimension synchrnous channle arrays used to simulate the 2-d synchronous channel array\n// channel right[i][j] is represented as c[i*N + j] \nchannel right[M*N] 0;\nchannel down[M*N] 0;\n\n//The system is a network of cells, messages transimit from one cell to its adjacent cell horizontally or vertically\nSend(i,j) = right[i*N]!i*N -> Send(i,j)\n         [] down[j]!j -> Send(i,j);\n \nReceive(i,j) = right[(i+1)*N-1]?x -> Receive(i,j)\n         [] down[(M-1)*N+j]?x -> Receive(i,j);\n         \nCell(i,j) = [(j+1)%N != 0]right[i*N+j]?x -> right[(i*N+j+1)]!x -> Cell(i,j)\n         [] [(i+1)%M != 0]down[i*N+j]?x -> down[((i+1)*N+j)]!x -> Cell(i,j);\n         \nSystem() = ||| i:{0..(M-1)}@(|||j:{0..(N-1)}@(Send(i,j)|||Receive(i,j)|||Cell(i,j)));\n\n#assert System() deadlockfree;"
  },
  {
    "id": "dbm",
    "name": "DBM (Difference Bound Matrix) Testing",
    "matchtype": "loose match",
    "description": "This model demonstrates DBM (Difference Bound Matrix) operations and testing in PAT using the PAT.Lib.DBM and supporting C# libraries. It features two concurrent tests (DBMTest1 and DBMTest2) that dynamically create, update, and evaluate timing constraints over a configurable number of timers.",
    "variable": "num_timers (at least 1) and clock_ceiling (at least 1)",
    "implementation": "#import \"PAT.Lib.DBM\";\n#import \"PAT.Lib.Set\";\n#import \"PAT.Math\";\n\n//DBM model has two DBMs: dbm1 and dbm2\n#define N 2;//the number of clocks of each DBM\n#define Ceiling 2;//the number of constraints added in each DBM\n#define Bound 4; //the timer bound\n\nvar<DBM> dbm1 = new DBM(Ceiling);\nvar<Set> timers1 = new Set();\nvar timerCount1 = 0;\nvar timerID1 = 1;\nvar result1 = false;\nvar isBounded = true;\nvar containsClock1 = false;\nvar stopped = false;\n\n\nDBMTest1() = ifa(timerCount1 < N) \n\t\t\t {\n\t\t\t\tnewTimerID{timerID1 = dbm1.GetNewTimerID();stopped=false} -> AddTimer.timerID1{dbm1.AddTimer(timerID1); timers1.Add(timerID1); timerCount1 = timers1.Count();} -> \n\t\t\t\t(Delay{dbm1.Delay()} -> \t\t\t\t\t\t\n\t\t\t\t(OneCycle1; \n\t\t\t\t\t\t check{result1 = dbm1.IsConstraintNotSatisfied(); isBounded=dbm1.IsTimersBounded(Bound);} -> \n\t\t\t\t\t\t ifa (!result1)\n\t\t\t\t\t\t {\n\t\t\t\t\t\t \tConstraintSatisfied -> (KeepTProcess1(timerCount1, call(Pow, 2, timerCount1)); (DBMTest1() [] ResetProcess1(timerCount1)))\n\t\t\t\t\t\t }\n\t\t\t\t\t\t else \n\t\t\t\t\t\t {\n\t\t\t\t\t\t \tConstraintNotSatisfied{dbm1 = new DBM(Ceiling); timers1 = new Set(); timerCount1 =0; timerID1 = 1;} -> DBMTest1()\n\t\t\t\t\t\t }\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\tstop{stopped =true;} -> DBMTest1()\n\t\t\t };\n\nOneCycle1() = (AddCProcess1(timerCount1); OneCycle1)\n\t      \t  [] (Clone{dbm1.Clone()} -> OneCycle1)\n\t     \t  [] Skip;\n\t\t\t\t\nResetProcess1(size) = ifa(size > 0) { \n\t\t\t\t \t[]t:{0..size-1}@ResetTimer{dbm1.ResetTimer(timers1.Get(t))} -> DBMTest1()\n\t\t\t\t  \t} else {\n\t\t\t\t\t  DBMTest1()\n\t\t\t\t  };\n\t\t\t\t\nKeepTProcess1(size, powset) =  ifa(size > 0) \n\t\t\t\t\t   {\n\t\t\t\t\t \tifa(powset ==1)\n\t\t\t\t\t \t{\n\t\t\t\t\t \t\tKeepTimers.1{dbm1 = dbm1.KeepTimers(timers1.GetSubsetByIndex(1)); timerCount1 = timers1.Count(); containsClock1=timers1.Contains(1); } -> Skip\n\t\t\t\t\t \t}\n\t\t\t\t\t \t else\n\t\t\t\t\t \t{\n\t\t\t\t\t  \t[] t:{1..powset-1}@KeepTimers.t{dbm1 = dbm1.KeepTimers(timers1.GetSubsetByIndex(t)); timerCount1 = timers1.Count(); containsClock1=timers1.Contains(1);} -> Skip\n\t\t\t\t\t \t}\n\t\t\t\t\t   };\t\t\t\t\t\nAddCProcess1(size) = ifa(size > 0) {\n\t\t\t\t\t([] t:{0..size-1}@ ([]op:{0..2}@ ([]value:{0..Ceiling}@ AddConstraint.t.op.value{dbm1.AddConstraint(timers1.Get(t), op, value);} -> Skip )))\n\t\t\t\t\t};\t \n\t\t\t\t\t \n\t\t\t\t\t\n#assert DBMTest1 deadlockfree;\n\n#define goal timerID1 == 0;\n#assert DBMTest1 reaches goal;\n\n#define goal1 isBounded == true;\n#assert DBMTest1 |= []goal1;\n\n#define goal2 stopped==true || containsClock1 == false;\n#assert DBMTest1 |= []<>goal2;\t\n\t\n//==============================================================================\nvar<DBM> dbm2 = new DBM(Ceiling);\nvar<Set> timers2 = new Set();\nvar timerCount2 = 0;\nvar timerID2 = 1;\nvar result2 = false;\nvar isBounded2 = true;\nvar containsClock2 = false;\nvar stopped2 = false;\n\nDBMTest2() = ifa(timerCount2 < N)\n\t\t\t{\n\t\t\t\tnewTimerID{timerID2 = dbm2.GetNewTimerID();stopped2=false} -> AddTimer.timerID2{dbm2.AddTimer(timerID2); timers2.Add(timerID2); timerCount2 = timers2.Count();} -> \n\t\t\t\t(Delay{dbm2.Delay()} -> \t\t\t\t\t\t\n\t\t\t\t(OneCycle2; \n\t\t\t\t\t\t check{result2 = dbm2.IsConstraintNotSatisfied(); isBounded2=dbm2.IsTimersBounded(Bound);} -> \n\t\t\t\t\t\t ifa (!result2)\n\t\t\t\t\t\t {\n\t\t\t\t\t\t \tConstraintSatisfied -> (KeepTProcess2(timerCount2, call(Pow, 2, timerCount2)); (DBMTest2() [] ResetProcess2(timerCount2)))\n\t\t\t\t\t\t }\n\t\t\t\t\t\t else \n\t\t\t\t\t\t {\n\t\t\t\t\t\t \tConstraintNotSatisfied{dbm2 = new DBM(Ceiling); timers2 = new Set(); timerCount2 =0; timerID2 = 1;} -> DBMTest2()\n\t\t\t\t\t\t }\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstop{stopped2 =true;} -> DBMTest2()\n\t\t\t}\n\t\t\t;\n\nOneCycle2 = (AddCProcess2(timerCount2); OneCycle2)\n\t\t[] (Clone{dbm2.Clone()} -> OneCycle2)\n\t\t[] Skip;\n\t\t\t\nResetProcess2(size) = ifa(size > 0) { \n\t\t\t\t []t:{0..size-1}@ResetTimer{dbm2.ResetTimer(timers2.Get(t))} -> DBMTest2()\n\t\t\t\t } else {\n\t\t\t\t  DBMTest2()\n\t\t\t\t };\n\t\t\t\nKeepTProcess2(size, powset) = ifa(size > 0) \n\t\t\t\t\t  {\n\t\t\t\t\t \tifa(powset ==1)\n\t\t\t\t\t \t{\n\t\t\t\t\t \t\tKeepTimers.1{dbm2 = dbm2.KeepTimers(timers2.GetSubsetByIndex(1)); timerCount2 = timers2.Count(); containsClock2=timers2.Contains(1); } -> Skip\n\t\t\t\t\t \t}\n\t\t\t\t\t \telse\n\t\t\t\t\t \t{\n\t\t\t\t\t  \t[] t:{1..powset-1}@KeepTimers.t{dbm2 = dbm2.KeepTimers(timers2.GetSubsetByIndex(t)); timerCount2 = timers2.Count(); containsClock2=timers2.Contains(1);} -> Skip\n\t\t\t\t\t \t}\n\t\t\t\t\t  };\n\t\t\t\t\nAddCProcess2(size) = ifa(size > 0) {\n\t\t\t\t([] t:{0..size-1}@ ([]op:{0..2}@ ([]value:{0..Ceiling}@ AddConstraint.t.op.value{dbm2.AddConstraint(timers2.Get(t), op, value);} -> Skip )))\n\t\t\t\t};\t \n\t\t\t\n//==============================================================================\n aDBMTest = DBMTest1 ||| DBMTest2;\n\n#assert aDBMTest deadlockfree;\n\n#define goal3 timerID1 == 0;\n#assert aDBMTest reaches goal3;\n\n#define goal4 isBounded == true && isBounded2 == true;\n#assert aDBMTest |= []goal4;\n\n#define goal5 (stopped==true || containsClock1 == false) && (stopped2 ==true || containsClock2 == false);\n#assert aDBMTest |= []<>goal5;"
  },
  {
    "id": "entrance",
    "name": "Entrance Gate System",
    "matchtype": "loose match",
    "description": "This model represents an Entrance Gate System secured by a 4-digit PIN verification process. It demonstrates how different system components\u2014including user input, controller logic, database checking, and peripheral devices\u2014interact via channels to manage access control.",
    "variable": "",
    "implementation": "#define N 4;\n#define RESET 77;\n\nvar pin[N];\nvar result = 0;\nvar dooropen = 0;\nvar alarm = 0;\nvar symbol = 0;\n\nchannel pw 0;\nchannel i2ctr 0;\nchannel ctr2db 0;\nchannel db2ctr 0;\nchannel i2d 0;\nchannel ctr2a 0;\nchannel ctr2alm 0;\n\nchannel flag 0;\n\nUser() = User2() [] User1(); flag?x -> if(dooropen == 1) { enterdoor -> Skip } else { User() };\n\nUser1() = pw!1 -> pw!1 -> pw!1 -> pw!1 -> Skip;\n\nUser2() = pw!2 -> pw!RESET -> pw!2 -> pw!2 -> pw!2 -> pw!2 -> Skip;\n\nInput() = pw?x -> check{symbol = x} -> \n          if(symbol == RESET) { \n            Input() \n          }\n          else {\n            input1{ pin[0] = symbol } -> i2d!symbol -> pw?y -> check{ symbol = y } -> \n            if(symbol == RESET){\n              Input()\n            }\n            else{\n              input2{ pin[1] = symbol } -> i2d!symbol -> pw?z ->check{ symbol = z } ->\n              if(symbol == RESET){\n                Input()\n              }\n              else{\n                input3{ pin[2] = symbol } -> i2d!symbol -> pw?k -> check{symbol = k} ->\n                if(symbol == RESET) \n                {\n                  Input()\n                }\n                else{\n                  input4{ pin[3] = symbol } -> i2d!symbol -> i2ctr!1 -> Input()\n                }\n              }\n            }\n          };\n\nDisplay() = i2d?x -> display -> Display();\n\nController() = i2ctr?x -> ctr2db!x -> db2ctr?x -> if(result ==1) { ctr2a!1 -> flag!1 -> Controller() } else { ctr2alm!1 -> flag!1 -> Controller() };\n\nDBMS() = ctr2db?x -> \n         if(pin[0]==1 && pin[1]==1 && pin[2]==1 && pin[3]==1) {\n            checkOK{result = 1;}->  db2ctr!1 -> DBMS()\n         } \n         else {\n            checkFail{result = 0;} -> db2ctr!1 -> DBMS()\n         };\n\nAlarm() = ctr2alm?x -> alarmon{alarm = 1} -> alarmoff{alarm = 0} -> Alarm();\n\nActuator() = ctr2a?x -> opendoor{dooropen = 1;} -> closedoor{dooropen = 0} -> Actuator();\n\nSystem() = User() ||| Input() ||| Controller() ||| DBMS() ||| Display() ||| Actuator() ||| Alarm();\n\n#define pre pin[0]==1 && pin[1]==1 && pin[2]==1 && pin[3]==1;\n#define pos dooropen == 1;\n#define error result == 0 && dooropen == 1;\n#define alert alarm == 1;\n\n\n#assert System() |= [] pre -> <> pos;\n#assert System() reaches error;\n#assert System() |= [] pos -> <> alert;"
  },
  {
    "id": "distributed",
    "name": "Distributed System with Hardware API",
    "matchtype": "loose match",
    "description": "This model describes a Distributed System with Hardware API, where two users interact with a central server that uses hardware operations (e.g., LCD blinking) to reflect system state transitions.",
    "variable": "",
    "implementation": "#import \"PAT.Lib.HardwareAPIs\";\n\n#define USER_CONNECT 77;\n#define SERVER_READY 78;\n#define DATA 79;\n#define POWER_ON 80;\n\nchannel chAdmin 0;\nchannel chA 0;\nchannel chB 0;\n\nAdmin() = chAdmin!POWER_ON -> Skip;\n\nUser1() = chA!USER_CONNECT -> chA?SERVER_READY -> SendData1();\nSendData1() = chA!DATA -> send_data_1 -> ReceiveData1();\nReceiveData1() = chA?x -> receive_data_1 -> SendData1();\n\nUser2() = chB!USER_CONNECT -> chB?SERVER_READY -> ReceiveData2();\nReceiveData2() = chB?x -> receive_data_2 -> SendData2();\nSendData2() = chB!DATA -> send_data_2 -> ReceiveData2();\n\n\nServer() = chAdmin?POWER_ON -> power_up {call(LCD_blink,1)} -> initializatioin -> User1Connected();\nUser1Connected() = chA?USER_CONNECT {call(LCD_blink,2)} -> chA!SERVER_READY -> User2Connected();\nUser2Connected() = chB?USER_CONNECT {call(LCD_blink,3)} -> chB!SERVER_READY -> transimitData();\ntransimitData() = chA?x {call(LCD_blink,4)} -> chB!x {call(LCD_blink,5)} -> transimitData();\n\nSystem = User1() ||| Server() ||| User2() ||| Admin();\n\n\n#assert System deadlockfree;"
  },
  {
    "id": "cscode",
    "name": "CS Code Generation Example",
    "matchtype": "loose match",
    "description": "This model serves as a CS code generation example, illustrating a system composed of multiple interacting processes with different execution sequences.",
    "variable": "",
    "implementation": "B() = e1 -> e2 -> p1 -> B();\nC() = e4 -> e3 -> p2 -> C();\nD() = e2 -> p3 -> D();\nE() = B() [] C();\nA() = D() || E();\n\n#assert A deadlockfree;"
  }
]