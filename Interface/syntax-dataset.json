{
    "general_info": "1. PAT's system implementation is process-oriented, centering around events, processes, and their interactions to model and verify system behaviors.\n2. PAT extends the classic process algebra, Communicating Sequential Processes (CSP), by supporting standard CSP syntax while introducing additional constructs such as mutable variables, imperative-style state updates, and model-checking capabilities. While CSP process interaction remains the foundation, PAT incorporates features reminiscent of C#, such as structured variable declarations, conditional expressions, and imperative-style assignments. This allows for more expressive modeling but also introduces syntax and semantics that differ from traditional CSP.\n3. For model checking, we focus on three aspects: Deadlock-freeness, Reachability, and LTL properties",
    "pitfalls_rules": "1. Semicolons\nIn PAT, semicolons are generally required after all statements; the only exception is inside process expressions (e.g., with ->, [], or |||), where semicolons are not used.\nExample: #define N 5;\nExample: var board[N*N];\nExample: D() = e2 -> p3 -> D();\nExample: E() = B() [] C();\nExample: #assert A deadlockfree;\n\n2. Constants\nExample: #define max 5;\nExample: #define N 2;\n\n3. Variables\nExample: var knight = 0;\nExample: var engine = off;\n\n4. Array initialization:\n4.1. Remember to use square brackets [] to list out the values of the array.\nExample: var owner[N] = [far, far];\nExample: var board=[3, 5, 6, 0, 2, 7];\n\n4.2. For PAT's 2d arrays, it's important to note that their values **must be** initialized with a single flat list, nested lists aren't supported.\nExample: var board[2][3] = [0,0,0,1,1,1];\n\n5. Enumerations\nRemember to use curly brackets {} immediately after the keyword enum, enclosing the variables without specifying a name.\nExample: enum {unlock, lock, open};\nExample: enum {off, on};\n\n6. System Definitions:\n6.1. Guarded conditions\nRemember to use square brackets [] to enclose the guard condition that needs to be satisfied to execute the guarded process.\nSyntax: [cond] Process\nExample: [owner[i] == far]\nExample: [key == i && owner[i] == in]\nExample: [owner[i] == near || owner[i]==far]\n\n6.2. Process definition:\nRemember that each process definition should typically transition back to itself or another process using the -> operator to ensure continuity. If a process does not transition, it will terminate upon execution, which may lead to unintended deadlocks or premature termination unless explicitly intended.\nExample: VM() = insertcoin -> coffee -> VM();\nExample: owner_pos(i) = [owner[i] == far] towards.i{owner[i] = near;} -> owner_pos(i);\nData operations can take place inside events:\nExample: towards.i{owner[i] = near;}\n\n6.3. Process assembling:\nThree options available to assemble different processes into a system: interleaving, parallel composition, or choices.\n- Interleaving: used when multiple processes can run concurrently without barrier synchronization.\n  Syntax: ||| x:{0..n} @ P(x)\n  Example: car() = ||| i:{0..N-1} @ (owner_pos(i) ||| key_pos(i) ||| door_op(i) ||| motor(i));\n- Parallel composition: used when multiple processes run with barrier synchronization.\n  Syntax: || x:{0..n} @ P(x);\n  Example: College() = ||x:{0..N-1}@(Phil(x)||Fork(x));\n- Choices: used when only one process will be selected to execute at a time.\n  Syntax: [] x:{0..n} @ P(x);\n- Special Syntax: assembling **infinite** number of processes.\n  Syntax: |||{..} @ (P() ||| Q());\n- Special Syntax: **interrupt** is a reserved keyword to define interruption.\n  Syntax: sys = (|||i:{0..N-1} @ (process1(i) ||| process2(i))) interrupt (action1 -> action2 -> Stop);\n\n7. Assertions\n7.1. Deadlock-freeness checks\nSyntax: use the keyword \"deadlockfree\".\nExample: #assert System deadlockfree;\n\n7.2. Reachability checks\nSyntax: define states and use the keyword \"reaches\" in the assertion to check whether the defined states are reachable.\nExample: #define goal1  (!on && dim == 50); #assert System reaches goal1;\n\n7.3. LTL properties\nSyntax: all states (if any are involved) need to be separately defined before composing the LTL formula in the assertion. The LTL operators should only appear in assertions, not state definitions.\nExample: #assert System |= [](turnOn -> <> turnOff);\nExamples: #define light50 (on && dim==50); #assert System |= []<>light50;"
}