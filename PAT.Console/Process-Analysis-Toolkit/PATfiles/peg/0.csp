#define X -1;
#define P 1;
#define E 2;
#define S 1; //sticky has the same value as P now.

//===== Board 9 =========
#define initEmptyX 4;
#define initEmptyY 3;
#define W 7;
#define H 8;
var board[H][W] = 
	         [P,P,P,P,P,P,P,
           P,P,P,P,P,P,P,
           P,P,P,P,P,P,P,
           S,S,P,P,P,P,P,
           S,S,P,E,P,P,S,
           S,S,S,P,S,S,S,
           X,X,S,S,S,X,X,
           X,X,S,S,S,X,X];
    
var pegsCounter = 47;

//four different ways of jumping
Up(i, j) = [i-2>=0]([board[i-2][j]==E && board[i-1][j]== P]up{board[i-2][j] = P; board[i-1][j] = E; board[i][j] = E; pegsCounter--;} -> Game()); 
Left(i, j) = [j-2>=0]([board[i][j-2]==E && board[i][j-1]== P]left{board[i][j-2] = P; board[i][j-1] = E; board[i][j] = E; pegsCounter--;} -> Game()); 
Down(i, j) = [i+2<H]([board[i+2][j] != X && board[i+2][j]==E && board[i+1][j]== P]down{board[i+2][j] = P; board[i+1][j] = E; board[i][j] = E; pegsCounter--;} -> Game());  
Right(i, j) = [j+2<W]([board[i][j+2] != X && board[i][j+2]==E && board[i][j+1]== P]right{board[i][j+2] = P; board[i][j+1] = E; board[i][j] = E; pegsCounter--;} -> Game()); 

//if there is a peg in the cell, it makes four diffferent moves
Peg(i,j) = [board[i][j]==P](Up(i,j) [] Left(i,j) [] Down(i,j) [] Right(i,j));
Game() = []i:{0..H-1};j:{0..W-1}@ Peg(i,j);

#define goal pegsCounter == 1 && board[initEmptyX][initEmptyY] == P;
#assert Game() reaches goal;