[
    {
        "nl": "// \"CHANNELSIZE\": defines the maximum capacity of channels (set to 1)\n\n// \"c\": channel with capacity \"CHANNELSIZE\", representing an unreliable channel\n// \"d\": channel with capacity \"CHANNELSIZE\", representing a perfect channel\n// \"tmr\": synchronous channel with capacity 0 (used between \"Sender\" and \"Timer\" to implement premature timeout)\n\n// \"Sender(alterbit)\" process\n// either channel \"c\" sends out the bit \"alterbit\", then \"Skip\", or experience a \"lost\" event then \"Skip\"\n// then send 1 over channel \"tmr\" (signal a timeout start) and transition to \"Wait4Response(alterbit)\"\n\n// \"Wait4Response(alterbit)\" process\n// wait to receive a value \"x\" from \"d\", then, if \"x\" equals \"alterbit\", atomically\n// send 0 through channel \"tmr\" (cancel timeout) and transition to \"Sender(1-alterbit)\" (toggle the bit)\n// else, remain in \"Wait4Response(alterbit)\" to wait for the correct acknowledgment\n// alternatively, if a timeout signal 2 is received from the channel \"tmr\", transition to \"Sender(alterbit)\" without toggling the bit\n\n// \"Receiver(alterbit)\" process\n// wait to receive a value \"x\" from \"c\", then, if \"x\" equals \"alterbit\", atomically\n// send \"alterbit\" over channel \"d\" (acknowledgment) and transition to \"Receiver(1-alterbit)\" (toggle the bit)\n// else, remain in \"Receiver(alterbit)\" to wait for the correct message\n\n// \"Timer\" process: synchronizes with \"Sender\" to handle timeouts\n// wait to receive 1 from channel \"tmr\" (start timeout), then either: wait to receive 0 from channel \"tmr\" (cancel timeout) and recurse to \"Timer\", or send 2 over channel \"tmr\" (indicate a premature timeout) and recurse to \"Timer\"\n\n// \"ABP\": overall system defined as the interleaving of \"Sender(0)\", \"Receiver(0)\", and \"Timer\"\n\n// assert that the \"ABP\" system is deadlock free (i.e., it never reaches a state with no further moves and without successful termination)\n// assert in LTL that the \"ABP\" system always eventually performs the action \"lost\"",
        "code": "#define CHANNELSIZE 1; \n\nchannel c CHANNELSIZE; \nchannel d CHANNELSIZE; \nchannel tmr 0; \n\nSender(alterbit) =\n    (c!alterbit -> Skip [] lost -> Skip);\n                                  tmr!1 -> Wait4Response(alterbit);\n\nWait4Response(alterbit) = \n    (d?x -> ifa (x == alterbit) {        \n            tmr!0 -> Sender(1 - alterbit)}   \n        else {Wait4Response(alterbit)})        \n    [] tmr?2 -> Sender(alterbit);           \n\nReceiver(alterbit) =\n    c?x -> ifa (x == alterbit) {            \n            d!alterbit -> Receiver(1 - alterbit)} \n        else {Receiver(alterbit)};              \n\nTimer = \n    tmr?1 -> (tmr?0 -> Timer [] tmr!2 -> Timer);\n\nABP = Sender(0) ||| Receiver(0) ||| Timer;\n\n#assert ABP deadlockfree;\n#assert ABP |= []<> lost;"
    },
    {
        "nl": "// \"N\": number of processes in the system (set to 2)\n\n// \"step\": array representing the protocol step for each process\n// \"pos\": array representing the turn or position of each process\n// \"counter\": counts the number of processes currently in the critical section\n\n// \"Process0()\": process for process 0; it begins by invoking \"Repeat0(1)\", then performs the critical session action \"cs.0\" (which increments \"counter\"), followed by \"reset\" (which resets \"pos[0]\" and decrements \"counter\"), and finally recurses to \"Process0()\"\n\n// Definition of the \"Repeat0(j)\" process\n// if j is smaller than N, perform the action \"update.0.1\" to set \"pos[0]\" to j\n// then perform the action \"update.0.2\" to set \"step[j]\" to 0\n// then, if either \"step[j]\" is nonzero, or \"pos[1]\" is smaller than j, perform the action \"idle.j\" and recursively call \"Repeat0(j+1)\"\n// alternatively, if j equals to N, perform the action \"Skip\"\n\n// \"Process1()\": process for process 1; it begins by invoking \"Repeat1(1)\", then performs the critical session action \"cs.1\" (which increments \"counter\"), followed by \"reset\" (which resets \"pos[1]\" and decrements \"counter\"), and finally recurses to \"Process1()\"\n\n// Definition of the \"Repeat1(j)\" process\n// if j is smaller than N, perform the action \"update.1.1\" to set \"pos[1]\" to j\n// then perform the action \"update.1.2\" to set \"step[j]\" to 1\n// then, if either \"step[j]\" does not equal to 1, or \"pos[0]\" is smaller than j, perform the action \"idle.j\" and recursively call \"Repeat1(j+1)\"\n// alternatively, if j equals to N, perform the action \"Skip\"\n\n// \"Peterson()\": overall system defined as the interleaving (|||) of \"Process0()\" and \"Process1()\"\n\n// \"goal\": defined as the state where \"counter\" is greater than 1 (i.e., more than one process is in the critical session, which violates mutual exclusion)\n\n// assert that the \"Peterson()\" system can reach the state \"goal\"\n// assert in LTL that the \"Peterson()\" system always eventually performs the action \"cs.0\"",
        "code": "#define N 2;\n\nvar step[N];       \nvar pos[N];        \nvar counter = 0;   \n\nProcess0() = Repeat0(1); cs.0{counter = counter+1;} -> reset{pos[0] = 0; counter = counter-1;} -> Process0(); \n\nRepeat0(j) = \n   [j < N] update.0.1{pos[0] = j;} ->    \n   update.0.2{step[j] = 0;} ->            \n   ([step[j] != 0 || (pos[1] < j)]idle.j -> Repeat0(j+1)) \n   [] [j == N] Skip;                     \n\nProcess1() = Repeat1(1); cs.1{counter = counter+1;} -> reset{pos[1] = 0; counter = counter-1;} -> Process1(); \n\nRepeat1(j) = \n   [j < N] update.1.1{pos[1] = j;} ->    \n   update.1.2{step[j] = 1;} ->            \n   ([step[j] != 1 || (pos[0] < j)]idle.j -> Repeat1(j+1)) \n   [] [j == N] Skip;                     \n\nPeterson() = Process0() ||| Process1(); \n\n#define goal counter > 1; \n\n#assert Peterson() reaches goal; \n\n#assert Peterson() |= []<> cs.0;"
    },
    {
        "nl": "// \"Max\": maximum allowed crossing time (17 time units)\n// \"KNIGHT\": crossing time for the Knight (1 time unit)\n// \"LADY\": crossing time for the Lady (2 time units)\n// \"KING\": crossing time for the King (5 time units)\n// \"QUEEN\": crossing time for the Queen (10 time units)\n// \"Knight\": state variable for the Knight, initially 0 (south side)\n// \"Lady\": state variable for the Lady, initially 0 (south side)\n// \"King\": state variable for the King, initially 0 (south side)\n// \"Queen\": state variable for the Queen, initially 0 (south side)\n// \"time\": variable for the accumulated crossing time\n\n// \"South()\": the actions that can be performed for characters on the south side\n// if (\"time\" + \"LADY\") is not larger than \"Max\" (time will not exceed the maximum limit after the operation) and \"Knight\" and \"Lady\" are south (0), then \"go_knight_lady\" sets them to north (1) and increments \"time\" by \"LADY\", then transitions to \"North()\"\n// alternatively, if (\"time\" + \"KING\") is not larger than \"Max\" and \"Knight\" and \"King\" are south, then \"go_knight_king\" sets them to north and adds \"KING\" to \"time\", then transitions to \"North()\"\n// alternatively, if (\"time\" + \"QUEEN\") is not larger than \"Max\" and \"Knight\" and \"Queen\" are south, then \"go_knight_queen\" sets them to north and adds \"QUEEN\" to \"time\", then transitions to \"North()\"\n// alternatively, if (\"time\" + \"KING\") is not larger than \"Max\" and \"Lady\" and \"King\" are south, then \"go_lady_king\" sets them to north and adds \"KING\" to \"time\", then transitions to \"North()\"\n// alternatively, if (\"time\" + \"QUEEN\") is not larger than \"Max\" and \"Lady\" and \"Queen\" are south, then \"go_lady_queen\" sets them to north and adds \"QUEEN\" to \"time\", then transitions to \"North()\"\n// alternatively, if (\"time\" + \"QUEEN\") is not larger than \"Max\" and \"King\" and \"Queen\" are south, then \"go_king_queen\" sets them to north and adds \"QUEEN\" to \"time\", then transitions to \"North()\"\n// alternatively, if (\"time\" + \"KNIGHT\") is not larger than \"Max\" and \"Knight\" is south, then \"go_knight\" sets \"Knight\" to north and adds \"KNIGHT\" to \"time\", then transitions to \"North()\"\n// alternatively, if (\"time\" + \"LADY\") is not larger than \"Max\" and \"Lady\" is south, then \"go_lady\" sets \"Lady\" to north and adds \"LADY\" to \"time\", then transitions to \"North()\"\n// alternatively, if (\"time\" + \"KING\") is not larger than \"Max\" and \"King\" is south, then \"go_king\" sets \"King\" to north and adds \"KING\" to \"time\", then transitions to \"North()\"\n// alternatively, if (\"time\" + \"QUEEN\") is not larger than \"Max\" and \"Queen\" is south, then \"go_queen\" sets \"Queen\" to north and adds \"QUEEN\" to \"time\", then transitions to \"North()\"\n\n// \"North()\": the actions that can be performed for characters on the north side\n// if (\"time\" + \"LADY\") is not larger than \"Max\" and \"Knight\" and \"Lady\" are north (1), then \"back_knight_lady\" resets them to south (0) and adds \"LADY\" to \"time\", then transitions to \"South()\"\n// alternatively, if (\"time\" + \"KING\") is not larger than \"Max\" and \"Knight\" and \"King\" are north, then \"back_knight_king\" resets them to south and adds \"KING\" to \"time\", then transitions to \"South()\"\n// alternatively, if (\"time\" + \"QUEEN\") is not larger than \"Max\" and \"Knight\" and \"Queen\" are north, then \"back_knight_queen\" resets them to south and adds \"QUEEN\" to \"time\", then transitions to \"South()\"\n// alternatively, if (\"time\" + \"KING\") is not larger than \"Max\" and \"Lady\" and \"King\" are north, then \"back_lady_king\" resets them to south and adds \"KING\" to \"time\", then transitions to \"South()\"\n// alternatively, if (\"time\" + \"QUEEN\") is not larger than \"Max\" and \"Lady\" and \"Queen\" are north, then \"back_lady_queen\" resets them to south and adds \"QUEEN\" to \"time\", then transitions to \"South()\"\n// alternatively, if (\"time\" + \"QUEEN\") is not larger than \"Max\" and \"King\" and \"Queen\" are north, then \"back_king_queen\" resets them to south and adds \"QUEEN\" to \"time\", then transitions to \"South()\"\n// alternatively, if (\"time\" + \"KNIGHT\") is not larger than \"Max\" and \"Knight\" is north, then \"back_knight\" resets \"Knight\" to south and adds \"KNIGHT\" to \"time\", then transitions to \"South()\"\n// alternatively, if (\"time\" + \"LADY\") is not larger than \"Max\" and \"Lady\" is north, then \"back_lady\" resets \"Lady\" to south and adds \"LADY\" to \"time\", then transitions to \"South()\"\n// alternatively, if (\"time\" + \"KING\") is not larger than \"Max\" and \"King\" is north, then \"back_king\" resets \"King\" to south and adds \"KING\" to \"time\", then transitions to \"South()\"\n// alternatively, if (\"time\" + \"QUEEN\") is not larger than \"Max\" and \"Queen\" is north, then \"back_queen\" resets \"Queen\" to south and adds \"QUEEN\" to \"time\", then transitions to \"South()\"\n         \n// \"goal\": state where \"Knight\", \"Lady\", \"King\", and \"Queen\" are all 1 (all on the north side)\n// \"alter\": state where either, \"Knight\", \"Lady\", \"King\", and \"Queen\" are all 1 (all on the north side) and \"time\" is larger than \"Max\" (exceeds the maximum time allowed to pass), or, not all of \"Knight\", \"Lady\", \"King\", and \"Queen\" are 1\n// assert that \"South()\" can reach the \"goal\" state\n// assert that \"South()\" reaches \"goal\" with the minimum possible \"time\"\n// assert in LTL that \"South()\" always reaches the \"alter\" state",
        "code": "#define Max 17;\n#define KNIGHT 1;\n#define LADY 2;\n#define KING 5;\n#define QUEEN 10;\nvar Knight = 0;\nvar Lady = 0;\nvar King = 0;\nvar Queen = 0;\nvar time;\n\nSouth() =\n\t[(time+LADY) <= Max && Knight == 0 && Lady == 0]go_knight_lady{Knight = 1; Lady = 1; time = time+LADY;} -> North()\n         [] [(time+KING) <= Max && Knight == 0 && King == 0]go_knight_king{Knight = 1; King = 1; time = time+KING;} -> North()\n         [] [(time+QUEEN) <= Max && Knight == 0 && Queen == 0]go_knight_queen{Knight = 1; Queen = 1; time = time+QUEEN;} -> North()\n         [] [(time+KING) <= Max && Lady == 0 && King == 0]go_lady_king{Lady = 1; King = 1; time = time+KING;} -> North()\n         [] [(time+QUEEN) <= Max && Lady == 0 && Queen == 0]go_lady_queen{Lady = 1; Queen = 1; time = time+QUEEN;} -> North()\n         [] [(time+QUEEN) <= Max && King == 0 && Queen == 0]go_king_queen{King = 1; Queen = 1; time = time+QUEEN;} -> North()\n         [] [(time+KNIGHT) <= Max && Knight == 0]go_knight{Knight = 1; time = time+KNIGHT;} -> North()\n         [] [(time+LADY) <= Max && Lady == 0]go_lady{Lady = 1; time = time+LADY;} -> North()\n         [] [(time+KING) <= Max && King == 0]go_king{King = 1; time = time+KING;} -> North()\n         [] [(time+QUEEN) <= Max && Queen == 0]go_queen{Queen = 1; time = time+QUEEN;} -> North();\n\nNorth() =\n\t[(time+LADY) <= Max && Knight == 1 && Lady == 1]back_knight_lady{Knight = 0; Lady = 0; time = time+LADY;} -> South()\n         [] [(time+KING) <= Max && Knight == 1 && King == 1]back_knight_king{Knight = 0; King = 0; time = time+KING;} -> South()\n         [] [(time+QUEEN) <= Max && Knight == 1 && Queen == 1]back_knight_queen{Knight = 0; Queen = 0; time = time+QUEEN;} -> South()\n         [] [(time+KING) <= Max && Lady == 1 && King == 1]back_lady_king{Lady = 0; King = 0; time = time+KING;} -> South()\n         [] [(time+QUEEN) <= Max && Lady == 1 && Queen == 1]back_lady_queen{Lady = 0; Queen = 0; time = time+QUEEN;} -> South()\n         [] [(time+QUEEN) <= Max && King == 1 && Queen == 1]back_king_queen{King = 0; Queen = 0; time = time+QUEEN;} -> South()\n         [] [(time+KNIGHT) <= Max && Knight == 1]back_knight{Knight = 0; time = time+KNIGHT;} -> South()\n         [] [(time+LADY) <= Max && Lady == 1]back_lady{Lady = 0; time = time+LADY;} -> South()\n         [] [(time+KING) <= Max && King == 1]back_king{King = 0; time = time+KING;} -> South()\n         [] [(time+QUEEN) <= Max && Queen == 1]back_queen{Queen = 0; time = time+QUEEN;} -> South();\n         \n#define goal (Knight==1 && Lady==1 && King==1 && Queen==1);\n#define alter ((Knight==1 && Lady==1 && King==1 && Queen==1 && time > Max) || !(Knight==1 && Lady==1 && King==1 && Queen==1));\n#assert South() reaches goal;\n#assert South() reaches goal with min(time);\n#assert South() |= [] alter;"
    },
    {
         "nl": "// \"N\": number of processes (set to 2)\n// \"Delta\": maximum allowed time for the update-wait sequence (3 time units)\n// \"Epsilon\": waiting duration after updating \"x\" (4 time units)\n// \"Idle\": special value indicating that x is idle\n// \"x\": shared variable, initially set to \"Idle\"\n// \"counter\": variable that counts the number of processes in the critical section\n\n// \"P(i)\": process for process i\n// if \"x\" equals \"Idle\" (using ifb without else block)\n// performs \"update.i\" which sets \"x\" to i, followed by \"Wait[Epsilon]\", all within \"Delta\" time units\n// then, if \"x\" equals to i, executes \"cs.i\" (increments \"counter\"), followed by \"exit.i\", which decrements \"counter\" and resets \"x\" to \"Idle\", followed by recursing to \"P(i)\"\n// alternatively, if \"x\" does not equal to i, immediately recurses to \"P(i)\"\n// end of process \"P(i)\"\n\n// \"FischersProtocol\": overall system defined as the interleaving of \"P(i)\" for all i in {0..N-1}\n\n// assert that \"FischersProtocol\" is deadlock free\n// \"MutualExclusionFail\": defined state where \"counter\" is larger than 1 (indicating a mutual exclusion violation)\n// assert that \"FischersProtocol\" can reach the state \"MutualExclusionFail\"\n// \"request\": defines the state where \"x\" is not \"Idle\" (i.e., a process has made a request)\n// \"accessCS\": defines the state where \"counter\" > 0 (i.e., at least one process is in the critical session)\n// assert in LTL that always, if \"request\" happen then eventually \"accessCS\" will be performed\n// assert in LTL that always, if \"update.0\" occurs, eventually \"cs.0\" will happen",
        "code": "#define N 2;\n#define Delta 3;\n#define Epsilon 4;\n#define Idle -1;\nvar x = Idle;\nvar counter;\n\nP(i) =\n\tifb(x == Idle) {\n\t  \t((update.i{x = i} -> Wait[Epsilon]) within[Delta]);\n\t\t\t([x == i](cs.i{counter++} -> exit.i{counter--; x = Idle} -> P(i))\n\t    [] [x != i]P(i))\n\t   };\n\nFischersProtocol = ||| i:{0..N-1}@P(i);\n\n#assert FischersProtocol deadlockfree;\n#define MutualExclusionFail counter > 1;\n#assert FischersProtocol reaches MutualExclusionFail;\n#define request x != Idle;\n#define accessCS counter > 0;\n#assert FischersProtocol |= [](request -> <>accessCS);\n#assert FischersProtocol |= [](update.0 -> <>cs.0);"
    },
    {
        "nl": "// \"N\": number of owners in the system (set to 2)\n\n// enumerations used in the model\n// \"far\": represents an owner being out and far away from the \"car\"\n// \"near\": represents an owner being near and close enough to interact with the \"car\" (e.g., open/lock the \"door\" if holding the \"key\")\n// \"in\": represents an owner being inside the \"car\"\n\n// \"off\": indicates the \"engine\" is \"off\"\n// \"on\": indicates the \"engine\" is \"on\"\n\n// \"unlock\": indicates the \"door\" is unlocked (but closed)\n// \"lock\": indicates the \"door\" is locked (and must be closed)\n// \"open\": indicates the \"door\" is open\n\n// \"incar\": indicates the \"key\" is put inside the \"car\"\n// \"faralone\": indicates the \"key\" is put outside and far away\n\n// \"owner\": array representing each owner's position; initially, all owners are assumed to be \"far\" from the \"car\"\n\n// \"engine\": status of the car's engine; initially set to \"off\"\n// \"door\": status of the car's door; initially set to \"lock\"\n// \"key\": position of the key fob; initially, it is with the first owner (index 0)\n// \"moving\": indicates whether the \"car\" is moving (0 for stop, 1 for moving); initially, the \"car\" is not moving\n// \"fuel\": represents the available fuel; initially 10 units (e.g., 1 unit for a short drive, 5 units for a long drive)\n\n// Definition of the \"owner_pos\" subsystem for an owner with index i\n// if \"owner[i]\" is \"far\", the action \"towards.i\" makes \"owner[i]\" become \"near\" (owner approaches the car)\n// alternative branch separator\n// if \"owner[i]\" is \"near\", the action \"goaway.i\" makes \"owner[i]\" become \"far\" (owner moves away from the car)\n// alternative branch separator\n// if \"owner[i]\" is \"near\", the \"door\" is \"open\", and the \"car\" is not \"moving\", the action \"getin.i\" makes \"owner[i]\" become \"in\" (owner enters the car)\n// alternative branch separator\n// if \"owner[i]\" is \"in\", the \"door\" is \"open\", and the \"car\" is not \"moving\", the action \"goout.i\" makes \"owner[i]\" become \"near\" (owner exits the car)\n\n// Definition of the \"key_pos\" subsystem for an owner with index i\n// if \"key\" is with owner i and \"owner[i]\" is \"in\", the action \"putincar.i\" sets \"key\" to \"incar\" (key placed inside the car)\n// alternative branch separator\n// if \"key\" is with owner i and \"owner[i]\" is \"far\", the action \"putaway.i\" sets \"key\" to \"faralone\" (key stored away outside the car)\n// alternative branch separator\n// if either \"key\" is \"faralone\" and \"owner[i]\" is \"far\", or \"key\" is \"incar\" and \"owner[i]\" is \"in\", the action \"getkey.i\" returns \"key\" to owner i\n\n// Definition of the \"door_op\" subsystem for an owner with index i\n// if \"key\" is with \"owner[i]\", \"owner[i]\" is \"near\", \"door\" is \"lock\", and the \"car\" is not \"moving\", the action \"unlockopen.i\" sets \"door\" to \"open\" (unlocking and opening the door)\n// alternative branch separator\n// if \"owner[i]\" is \"near\", \"door\" is \"unlock\", and the \"car\" is not \"moving\", the action \"justopen.i\" sets \"door\" to \"open\" (simply opening the door)\n// alternative branch separator\n// if \"door\" is not \"open\" and \"owner[i]\" is \"in\", the action \"insideopen.i\" sets \"door\" to \"open\" (an inside command to open the door)\n// alternative branch separator\n// if \"door\" is \"open\", the action \"close.i\" sets \"door\" to \"unlock\" (closing the door without locking)\n// alternative branch separator\n// if \"door\" is \"unlock\" and \"owner[i]\" is \"in\", the action \"insidelock.i\" sets \"door\" to \"lock\" (locking the door from inside)\n// alternative branch separator\n// if \"door\" is \"unlock\", \"owner[i]\" is \"near\", and \"key\" is with owner i, the action \"outsidelock.i\" sets \"door\" to \"lock\" (locking the door from outside)\n\n// Definition of the \"motor\" subsystem for an owner with index i\n// if \"owner[i]\" is \"in\", and either \"key\" is with owner i or is \"incar\", and \"engine\" is \"off\" with nonzero \"fuel\", the action \"turnon.i\" sets \"engine\" to \"on\" (starting the engine)\n// alternative branch separator\n// if \"engine\" is \"on\", \"owner[i]\" is \"in\", and the \"car\" is not \"moving\", the action \"startdrive.i\" sets \"moving\" to 1 (starting to drive)\n// alternative branch separator\n// if the \"car\" is \"moving\" with nonzero \"fuel\", the action \"shortdrive.i\" decreases \"fuel\" by 1; if \"fuel\" becomes 0, \"engine\" is set to \"off\" and \"moving\" becomes 0 (modeling a short drive)\n// alternative branch separator\n// if the \"car\" is \"moving\" and \"fuel\" is greater than 5, the action \"longdrive.i\" decreases \"fuel\" by 5; if \"fuel\" becomes 0, \"engine\" is set to \"off\" and \"moving\" becomes 0 (modeling a long drive)\n// alternative branch separator\n// if \"engine\" is \"on\", the car is \"moving\", and \"owner[i]\" is \"in\", the action \"stop.i\" sets \"moving\" to 0 (stopping the car)\n// alternative branch separator\n// if \"fuel\" is 0 and \"engine\" is \"off\", the action \"refill\" resets \"fuel\" to 10 (refueling the car)\n// alternative branch separator\n// if \"engine\" is \"on\", the car is not \"moving\", and \"owner[i]\" is \"in\", the action \"turnoff.i\" sets \"engine\" to \"off\" (turning off the engine)\n\n// \"car\": overall system combining the \"motor\", \"door_op\", \"key_pos\", and \"owner_pos\" subsystems interleavingly for each owner (from index 0 to \"N\"-1)\n\n// defines \"runwithoutowner\": the car is \"moving\" while both \"owner[0]\" and \"owner[1]\" are \"far\" (testing if the car can move without any owner present)\n// defines \"ownerdrivetogether\": the car is \"moving\" with both \"owner[0]\" and \"owner[1]\" being \"in\" (testing if both owners can drive together)\n// defines \"keylockinside\": the \"key\" is \"incar\" and the \"door\" is \"lock\" while neither \"owner[0]\" nor \"owner[1]\" is \"in\" (testing if the key can be inadvertently locked inside)\n// defines \"drivewithoutengineon\": the car is \"moving\" while the \"engine\" is \"off\" (testing if the car can move without the engine running)\n// defines \"drivewithoutfuel\": the car is \"moving\" while \"fuel\" is 0 (testing if the car can move without fuel)\n// defines \"drivewithoutkeyholdbyother\": the car is \"moving\" with \"owner[1]\" \"in\", \"owner[0]\" \"far\", and \"key\" with owner 0 (testing if the car can be driven by owner 1 when the proper key holder owner 0 is not in the car)\n\n// assert that the \"car\" system is deadlock free, meaning it will not get stuck in a state where no further moves are possible and has not terminated successfully\n// assert in LTL that the \"car\" system always eventually performs the action \"longdrive.0\" (i.e., it is always the case that longdrive.0 will eventually occur)\n// assert that the \"car\" system can reach the state \"keylockinside\"\n// assert that the \"car\" system can reach the state \"runwithoutowner\"\n// assert that the \"car\" system can reach the state \"ownerdrivetogether\"\n// assert that the \"car\" system can reach the state \"drivewithoutengineon\"\n// assert that the \"car\" system can reach the state \"drivewithoutfuel\"\n// assert that the \"car\" system can reach the state \"drivewithoutkeyholdbyother\"",
        "code": "#define N 2;        \n\n#define far 0;      \n#define near 1;     \n#define in 2;       \n\n#define off 0;      \n#define on 1;       \n\n#define unlock 0;   \n#define lock 1;     \n#define open 2;     \n\n#define incar -1;    \n#define faralone -2; \n\nvar owner[N];       \nvar engine = off;   \nvar door = lock;    \nvar key = 0;        \nvar moving = 0;     \nvar fuel = 10;      \n\nowner_pos(i) = \n          [owner[i] == far]towards.i{owner[i] = near;} -> owner_pos(i) \n          [] \n          [owner[i] == near]goaway.i{owner[i] = far;} -> owner_pos(i) \n          [] \n          [owner[i] == near && door == open && moving == 0]getin.i{owner[i] = in;} -> owner_pos(i) \n          [] \n          [owner[i] == in && door == open && moving == 0]goout.i{owner[i] = near;} -> owner_pos(i);\n\nkey_pos(i) = \n          [key == i && owner[i] == in]putincar.i{key = incar;} -> key_pos(i)  \n          [] \n          [key == i && owner[i] == far]putaway.i{key = faralone;} -> key_pos(i) \n          [] \n          [(key == faralone && owner[i] == far) || (key == incar && owner[i] == in)]getkey.i{key = i;} -> key_pos(i);\n\ndoor_op(i) = \n          [key == i && owner[i] == near && door == lock && moving == 0]unlockopen.i{door = open;} -> door_op(i) \n          [] \n          [owner[i] == near && door == unlock && moving == 0]justopen.i{door = open;} -> door_op(i) \n          [] \n          [door != open && owner[i] == in]insideopen.i{door = open;} -> door_op(i) \n          [] \n          [door == open]close.i{door = unlock;} -> door_op(i) \n          [] \n          [door == unlock && owner[i] == in]insidelock.i{door = lock;} -> door_op(i) \n          [] \n          [door == unlock && owner[i] == near && key == i]outsidelock.i{door = lock;} -> door_op(i);\n\nmotor(i) = \n          [owner[i] == in && (key == i || key == incar) && engine == off && fuel != 0]turnon.i{engine = on;} -> motor(i) \n          [] \n          [engine == on && owner[i] == in && moving == 0]startdrive.i{moving = 1;} -> motor(i) \n          [] \n          [moving == 1 && fuel != 0]shortdrive.i{fuel = fuel - 1; if (fuel == 0) { engine = off; moving = 0; }} -> motor(i) \n          [] \n          [moving == 1 && fuel > 5]longdrive.i{fuel = fuel - 5; if (fuel == 0) { engine = off; moving = 0; }} -> motor(i) \n          [] \n          [engine == on && moving == 1 && owner[i] == in]stop.i{moving = 0;} -> motor(i) \n          [] \n          [fuel == 0 && engine == off]refill{fuel = 10;} -> motor(i) \n          [] \n          [engine == on && moving == 0 && owner[i] == in]turnoff.i{engine = off;} -> motor(i);\n\ncar = (|||i:{0..N-1} @ (motor(i) ||| door_op(i) ||| key_pos(i) ||| owner_pos(i))); \n\n#define runwithoutowner (moving == 1 && owner[0] == far && owner[1] == far); \n#define ownerdrivetogether (moving == 1 && owner[0] == in && owner[1] == in); \n#define keylockinside (key == incar && door == lock && owner[0] != in && owner[1] != in); \n#define drivewithoutengineon (moving == 1 && engine == off); \n#define drivewithoutfuel (moving == 1 && fuel == 0); \n#define drivewithoutkeyholdbyother (moving == 1 && owner[1] == in && owner[0] == far && key == 0);\n\n#assert car deadlockfree; \n#assert car |= []<> longdrive.0; \n#assert car reaches keylockinside; \n#assert car reaches runwithoutowner; \n#assert car reaches ownerdrivetogether; \n#assert car reaches drivewithoutengineon; \n#assert car reaches drivewithoutfuel; \n#assert car reaches drivewithoutkeyholdbyother;"
    },
    {
         "nl": "// \"N\": number of philosophers (and forks) in the system\n\n// \"Phil(i)\": process representing a philosopher with index i; it performs \"get.i.(i+1)%N\" (acquire fork on the right side), then \"get.i.i\" (acquire fork on the left side), then \"eat.i\" (eat), followed by \"put.i.(i+1)%N\" (release the right hand side fork) and \"put.i.i\" (release the left hand side fork), and then recurses to \"Phil(i)\"\n\n// \"Fork(x)\": process representing a fork with index x; it offers two alternative branches: first, it can be acquired by philosopher x via \"get.x.x\" and released via \"put.x.x\", or alternatively, it can be acquired by philosopher (x-1)%N via \"get.(x-1)%N.x\" and released via \"put.(x-1)%N.x\", then recurses to \"Fork(x)\"\n\n// \"College()\": overall system obtained by parallel composition over x in {0..N-1} of the processes \"Phil(x)\" and \"Fork(x)\"\n\n// assert that the \"College()\" system is deadlock free (i.e., it will not reach a state where no further actions are possible)\n// assert in LTL that the \"College()\" system always eventually performs the action \"eat.0\"",
        "code": "#define N 2;\n\nPhil(i) = get.i.(i+1)%N -> get.i.i -> eat.i -> put.i.(i+1)%N -> put.i.i -> Phil(i);\nFork(x) = get.x.x -> put.x.x -> Fork(x) [] get.(x-1)%N.x -> put.(x-1)%N.x -> Fork(x);\nCollege() = ||x:{0..N-1}@(Phil(x)||Fork(x));\n\n#assert College() deadlockfree;\n#assert College() |= []<> eat.0;"
    }
]